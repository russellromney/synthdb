{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SynthDB Documentation","text":"<p>A flexible database system with schema-on-write capabilities. SynthDB makes it easy to work with evolving data structures while maintaining familiar SQL-like interfaces.</p>"},{"location":"#what-is-synthdb","title":"What is SynthDB?","text":"<p>SynthDB is a modern database system that adapts to your data as it evolves. Unlike traditional databases that require predefined schemas, SynthDB allows you to add columns and modify data structures on the fly while maintaining data integrity and providing familiar query interfaces.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Flexible Schema: Store data with dynamic schemas that evolve as your application grows</li> <li>Automatic Views: Automatically generated SQL views that present data as traditional tables</li> <li>Schema Evolution: Add columns to existing tables without migration scripts</li> <li>Type Safety: Type-specific storage tables for optimal performance and data integrity</li> <li>History Tracking: Built-in audit trail with creation and update timestamps</li> <li>CLI Interface: Rich command-line interface for database operations</li> <li>Python API: Clean, well-documented Python API for programmatic access</li> <li>Multiple Backends: Supports Limbo and SQLite backends</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import synthdb\n\n# Create a connection\ndb = synthdb.connect('app.db')\n\n# Create table and add columns\ndb.create_table('users')\ndb.add_columns('users', {\n    'name': 'text',\n    'email': 'user@example.com',  # Infers text type\n    'age': 25,                    # Infers integer type\n    'active': True                # Infers boolean type\n})\n\n# Insert data with auto-generated ID\nuser_id = db.insert('users', {\n    'name': 'Alice',\n    'email': 'alice@example.com',\n    'age': 30,\n    'active': True\n})\n\n# Query data\nusers = db.query('users', 'age &gt; 25')\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Installation - Install SynthDB and its dependencies</li> <li>Quick Start - Get up and running in minutes</li> <li>Basic Concepts - Understand SynthDB's core concepts</li> <li>Connection API - Learn the modern Python API</li> </ol>"},{"location":"#documentation-sections","title":"Documentation Sections","text":""},{"location":"#user-guide","title":"\ud83d\udcda User Guide","text":"<p>Learn how to use SynthDB effectively with step-by-step guides and examples.</p>"},{"location":"#api-reference","title":"\ud83d\udd27 API Reference","text":"<p>Complete reference for all SynthDB classes, functions, and CLI commands.</p>"},{"location":"#examples","title":"\ud83d\ude80 Examples","text":"<p>Real-world examples and patterns for common use cases.</p>"},{"location":"#advanced-topics","title":"\u2699\ufe0f Advanced Topics","text":"<p>Deep dive into SynthDB's architecture, performance tuning, and troubleshooting.</p>"},{"location":"#development","title":"\ud83d\udee0\ufe0f Development","text":"<p>Information for contributors and developers working on SynthDB itself.</p>"},{"location":"#community-and-support","title":"Community and Support","text":"<ul> <li>GitHub: russellromney/synthdb</li> <li>Issues: Report bugs and request features</li> <li>PyPI: Install from PyPI</li> </ul>"},{"location":"#license","title":"License","text":"<p>SynthDB is released under the MIT License. See the LICENSE file for details.</p>"},{"location":"api/connection/","title":"Connection API Reference","text":"<p>The <code>Connection</code> class is the primary interface for interacting with SynthDB databases. It provides a clean, object-oriented API for all database operations.</p>"},{"location":"api/connection/#quick-reference","title":"Quick Reference","text":"<pre><code>import synthdb\n\n# Create connection\ndb = synthdb.connect('app.limbo')  # Uses Limbo by default\n\n# Table operations\ndb.create_table('users')\ndb.add_columns('users', {'name': 'text', 'age': 25})\n\n# Data operations\nuser_id = db.insert('users', {'name': 'Alice', 'age': 30})\nusers = db.query('users', 'age &gt; 25')\n\n# Inspection\ntables = db.list_tables()\ncolumns = db.list_columns('users')\n</code></pre>"},{"location":"api/connection/#connection-class","title":"Connection Class","text":""},{"location":"api/connection/#synthdb.Connection","title":"<code>synthdb.Connection(connection_info='db.db', backend=None, auto_init=True)</code>","text":"<p>SynthDB connection class providing a clean, object-oriented interface.</p> <p>This class encapsulates connection details and provides all database operations as methods, eliminating the need to pass connection info to every function.</p> <p>Examples:</p>"},{"location":"api/connection/#synthdb.Connection--initialize-with-file-database","title":"Initialize with file database","text":"<p>db = synthdb.connect('myapp.db', backend='sqlite')</p>"},{"location":"api/connection/#synthdb.Connection--create-and-use-tables","title":"Create and use tables","text":"<p>db.create_table('users') db.add_columns('users', {     'name': 'text',     'age': 25,     'email': 'user@example.com' })</p>"},{"location":"api/connection/#synthdb.Connection--insert-data-with-auto-generated-id","title":"Insert data with auto-generated ID","text":"<p>user_id = db.insert('users', {     'name': 'John Doe',     'age': 30,     'email': 'john@example.com' })</p>"},{"location":"api/connection/#synthdb.Connection--query-data","title":"Query data","text":"<p>users = db.query('users', 'age &gt; 25')</p> <p>Parameters:</p> Name Type Description Default <code>connection_info</code> <code>Union[str, Dict[str, Any]]</code> <p>Database file path or dict</p> <code>'db.db'</code> <code>backend</code> <code>str</code> <p>Database backend ('limbo', 'sqlite')</p> <code>None</code> <code>auto_init</code> <code>bool</code> <p>Automatically initialize database if it doesn't exist</p> <code>True</code> <p>Examples:</p>"},{"location":"api/connection/#synthdb.Connection--file-databases","title":"File databases","text":"<p>db = synthdb.connect('app.db', 'sqlite') db = synthdb.connect('app.limbo', 'limbo')</p>"},{"location":"api/connection/#synthdb.Connection--auto-detection-by-extension","title":"Auto-detection by extension","text":"<p>db = synthdb.connect('app.db')     # Uses SQLite db = synthdb.connect('app.limbo')  # Uses Limbo</p>"},{"location":"api/connection/#synthdb.Connection--connection-dict","title":"Connection dict","text":"<p>db = synthdb.connect({     'backend': 'sqlite',     'path': 'app.db' })</p> Source code in <code>synthdb/connection.py</code> <pre><code>def __init__(self, connection_info: Union[str, Dict[str, Any]] = 'db.db', \n             backend: str = None, auto_init: bool = True):\n    \"\"\"\n    Initialize SynthDB connection.\n\n    Args:\n        connection_info: Database file path or dict\n        backend: Database backend ('limbo', 'sqlite')\n        auto_init: Automatically initialize database if it doesn't exist\n\n    Examples:\n        # File databases\n        db = synthdb.connect('app.db', 'sqlite')\n        db = synthdb.connect('app.limbo', 'limbo')\n\n        # Auto-detection by extension\n        db = synthdb.connect('app.db')     # Uses SQLite\n        db = synthdb.connect('app.limbo')  # Uses Limbo\n\n        # Connection dict\n        db = synthdb.connect({\n            'backend': 'sqlite',\n            'path': 'app.db'\n        })\n    \"\"\"\n    self.connection_info = connection_info\n    self.backend_name = backend\n\n    # Auto-detect backend from connection string if not specified\n    if backend is None and isinstance(connection_info, str) and '://' in connection_info:\n        from .backends import parse_connection_string\n        self.backend_name, _ = parse_connection_string(connection_info)\n\n    # Auto-initialize database if requested\n    if auto_init:\n        try:\n            self.init_db()\n        except Exception:\n            # Database might already exist, which is fine\n            pass\n</code></pre>"},{"location":"api/connection/#synthdb.Connection.__repr__","title":"<code>__repr__()</code>","text":"<p>String representation of the connection.</p> Source code in <code>synthdb/connection.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"String representation of the connection.\"\"\"\n    backend = self.backend_name or 'auto'\n    if isinstance(self.connection_info, dict):\n        conn_desc = f\"{self.connection_info.get('backend', 'unknown')} connection\"\n    elif '://' in str(self.connection_info):\n        conn_desc = str(self.connection_info).split('://')[0] + ' connection'\n    else:\n        conn_desc = f\"file: {self.connection_info}\"\n    return f\"Connection({conn_desc}, backend={backend})\"\n</code></pre>"},{"location":"api/connection/#synthdb.Connection.add_column","title":"<code>add_column(table_name, column_name, data_type)</code>","text":"<p>Add a single column to a table.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>Name of the table</p> required <code>column_name</code> <code>str</code> <p>Name of the column</p> required <code>data_type</code> <code>str</code> <p>Data type ('text', 'integer', 'real', 'boolean', 'json', 'timestamp')</p> required <p>Returns:</p> Type Description <code>int</code> <p>Column ID</p> Source code in <code>synthdb/connection.py</code> <pre><code>def add_column(self, table_name: str, column_name: str, data_type: str) -&gt; int:\n    \"\"\"\n    Add a single column to a table.\n\n    Args:\n        table_name: Name of the table\n        column_name: Name of the column\n        data_type: Data type ('text', 'integer', 'real', 'boolean', 'json', 'timestamp')\n\n    Returns:\n        Column ID\n    \"\"\"\n    return _add_column(table_name, column_name, data_type, \n                      self.connection_info, self.backend_name)\n</code></pre>"},{"location":"api/connection/#synthdb.Connection.add_columns","title":"<code>add_columns(table_name, columns)</code>","text":"<p>Add multiple columns to a table at once with type inference.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>Name of the table</p> required <code>columns</code> <code>Dict[str, Union[str, Any]]</code> <p>Dictionary of column_name -&gt; type_or_sample_value</p> required <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Dictionary mapping column names to their IDs</p> <p>Examples:</p>"},{"location":"api/connection/#synthdb.Connection.add_columns--explicit-types","title":"Explicit types","text":"<p>ids = db.add_columns('users', {     'email': 'text',     'created_at': 'timestamp',     'metadata': 'json' })</p>"},{"location":"api/connection/#synthdb.Connection.add_columns--inferred-types-from-sample-values","title":"Inferred types from sample values","text":"<p>ids = db.add_columns('users', {     'email': 'user@example.com',      # -&gt; text     'age': 25,                        # -&gt; integer     'active': True,                   # -&gt; boolean     'created_at': '2023-12-25'        # -&gt; timestamp })</p> Source code in <code>synthdb/connection.py</code> <pre><code>def add_columns(self, table_name: str, columns: Dict[str, Union[str, Any]]) -&gt; Dict[str, int]:\n    \"\"\"\n    Add multiple columns to a table at once with type inference.\n\n    Args:\n        table_name: Name of the table\n        columns: Dictionary of column_name -&gt; type_or_sample_value\n\n    Returns:\n        Dictionary mapping column names to their IDs\n\n    Examples:\n        # Explicit types\n        ids = db.add_columns('users', {\n            'email': 'text',\n            'created_at': 'timestamp',\n            'metadata': 'json'\n        })\n\n        # Inferred types from sample values\n        ids = db.add_columns('users', {\n            'email': 'user@example.com',      # -&gt; text\n            'age': 25,                        # -&gt; integer\n            'active': True,                   # -&gt; boolean\n            'created_at': '2023-12-25'        # -&gt; timestamp\n        })\n    \"\"\"\n    valid_types = {\"text\", \"integer\", \"real\", \"boolean\", \"json\", \"timestamp\"}\n    column_ids = {}\n\n    with transaction_context(self.connection_info, self.backend_name) as (backend, connection):\n        for col_name, type_or_value in columns.items():\n            # Determine if it's a type name or sample value\n            if isinstance(type_or_value, str) and type_or_value in valid_types:\n                # It's an explicit type\n                data_type = type_or_value\n            else:\n                # It's a sample value - infer the type\n                data_type, _ = infer_type(type_or_value)\n\n            # Add the column using transaction context\n            column_id = _add_column(\n                table_name, col_name, data_type, self.connection_info, self.backend_name,\n                backend=backend, connection=connection\n            )\n            column_ids[col_name] = column_id\n\n    # Recreate views to include new columns\n    create_table_views(self.connection_info, self.backend_name)\n\n    return column_ids\n</code></pre>"},{"location":"api/connection/#synthdb.Connection.create_table","title":"<code>create_table(name)</code>","text":"<p>Create a new table.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Table name</p> required <p>Returns:</p> Type Description <code>int</code> <p>Table ID</p> Source code in <code>synthdb/connection.py</code> <pre><code>def create_table(self, name: str) -&gt; int:\n    \"\"\"\n    Create a new table.\n\n    Args:\n        name: Table name\n\n    Returns:\n        Table ID\n    \"\"\"\n    return _create_table(name, self.connection_info, self.backend_name)\n</code></pre>"},{"location":"api/connection/#synthdb.Connection.init_db","title":"<code>init_db()</code>","text":"<p>Initialize the database schema.</p> Source code in <code>synthdb/connection.py</code> <pre><code>def init_db(self) -&gt; None:\n    \"\"\"\n    Initialize the database schema.\n    \"\"\"\n    make_db(self.connection_info, self.backend_name)\n</code></pre>"},{"location":"api/connection/#synthdb.Connection.insert","title":"<code>insert(table_name, data, value=None, force_type=None, row_id=None)</code>","text":"<p>Insert data into a table with automatic or explicit ID management.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>Name of the table</p> required <code>data</code> <code>Union[Dict[str, Any], str]</code> <p>Dictionary of column-&gt;value pairs, OR column name (if value provided)</p> required <code>value</code> <code>Any</code> <p>Value to insert (if data is a column name)</p> <code>None</code> <code>force_type</code> <code>str</code> <p>Override automatic type inference</p> <code>None</code> <code>row_id</code> <code>int</code> <p>Explicit row ID (if None, auto-generates next available ID)</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The row ID (auto-generated or explicitly provided)</p> <p>Examples:</p>"},{"location":"api/connection/#synthdb.Connection.insert--auto-generated-id","title":"Auto-generated ID","text":"<p>user_id = db.insert('users', {'name': 'John', 'age': 25})</p>"},{"location":"api/connection/#synthdb.Connection.insert--explicit-id","title":"Explicit ID","text":"<p>db.insert('users', {'name': 'Jane'}, row_id=100)</p>"},{"location":"api/connection/#synthdb.Connection.insert--single-column","title":"Single column","text":"<p>db.insert('users', 'email', 'john@example.com')</p>"},{"location":"api/connection/#synthdb.Connection.insert--force-specific-type","title":"Force specific type","text":"<p>db.insert('users', 'age', '25', force_type='text')</p> Source code in <code>synthdb/connection.py</code> <pre><code>def insert(self, table_name: str, data: Union[Dict[str, Any], str], \n           value: Any = None, force_type: str = None, row_id: int = None) -&gt; int:\n    \"\"\"\n    Insert data into a table with automatic or explicit ID management.\n\n    Args:\n        table_name: Name of the table\n        data: Dictionary of column-&gt;value pairs, OR column name (if value provided)\n        value: Value to insert (if data is a column name)\n        force_type: Override automatic type inference\n        row_id: Explicit row ID (if None, auto-generates next available ID)\n\n    Returns:\n        The row ID (auto-generated or explicitly provided)\n\n    Examples:\n        # Auto-generated ID\n        user_id = db.insert('users', {'name': 'John', 'age': 25})\n\n        # Explicit ID\n        db.insert('users', {'name': 'Jane'}, row_id=100)\n\n        # Single column\n        db.insert('users', 'email', 'john@example.com')\n\n        # Force specific type\n        db.insert('users', 'age', '25', force_type='text')\n    \"\"\"\n    from .api import insert\n    return insert(table_name, data, value, self.connection_info, \n                 self.backend_name, force_type, row_id)\n</code></pre>"},{"location":"api/connection/#synthdb.Connection.list_columns","title":"<code>list_columns(table_name)</code>","text":"<p>List all columns in a table.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>Name of the table</p> required <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of column information dictionaries</p> Source code in <code>synthdb/connection.py</code> <pre><code>def list_columns(self, table_name: str) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    List all columns in a table.\n\n    Args:\n        table_name: Name of the table\n\n    Returns:\n        List of column information dictionaries\n    \"\"\"\n    return list_columns(table_name, self.connection_info, self.backend_name)\n</code></pre>"},{"location":"api/connection/#synthdb.Connection.list_tables","title":"<code>list_tables()</code>","text":"<p>List all tables in the database.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of table information dictionaries</p> Source code in <code>synthdb/connection.py</code> <pre><code>def list_tables(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    List all tables in the database.\n\n    Returns:\n        List of table information dictionaries\n    \"\"\"\n    return list_tables(self.connection_info, self.backend_name)\n</code></pre>"},{"location":"api/connection/#synthdb.Connection.query","title":"<code>query(table_name, where=None)</code>","text":"<p>Query data from a table.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>Name of the table to query</p> required <code>where</code> <code>str</code> <p>Optional WHERE clause</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of dictionaries representing rows</p> <p>Examples:</p>"},{"location":"api/connection/#synthdb.Connection.query--get-all-rows","title":"Get all rows","text":"<p>rows = db.query('users')</p>"},{"location":"api/connection/#synthdb.Connection.query--filter-rows","title":"Filter rows","text":"<p>rows = db.query('users', 'age &gt; 25')</p> Source code in <code>synthdb/connection.py</code> <pre><code>def query(self, table_name: str, where: str = None) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Query data from a table.\n\n    Args:\n        table_name: Name of the table to query\n        where: Optional WHERE clause\n\n    Returns:\n        List of dictionaries representing rows\n\n    Examples:\n        # Get all rows\n        rows = db.query('users')\n\n        # Filter rows\n        rows = db.query('users', 'age &gt; 25')\n    \"\"\"\n    return query_view(table_name, where, self.connection_info, self.backend_name)\n</code></pre>"},{"location":"api/connection/#synthdb.Connection.refresh_views","title":"<code>refresh_views()</code>","text":"<p>Refresh all table views in the database.</p> Source code in <code>synthdb/connection.py</code> <pre><code>def refresh_views(self) -&gt; None:\n    \"\"\"\n    Refresh all table views in the database.\n    \"\"\"\n    create_table_views(self.connection_info, self.backend_name)\n</code></pre>"},{"location":"api/connection/#synthdb.Connection.upsert","title":"<code>upsert(table_name, data, key_columns, row_id=None)</code>","text":"<p>Insert or update data based on key columns.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>Name of the table</p> required <code>data</code> <code>Dict[str, Any]</code> <p>Column data to insert/update</p> required <code>key_columns</code> <code>List[str]</code> <p>Columns to use for matching existing rows</p> required <code>row_id</code> <code>int</code> <p>Explicit row ID for new inserts (ignored for updates)</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>Row ID of inserted or updated row</p> <p>Examples:</p>"},{"location":"api/connection/#synthdb.Connection.upsert--insert-new-user-or-update-if-email-exists","title":"Insert new user or update if email exists","text":"<p>user_id = db.upsert('users',      {'name': 'John', 'email': 'john@example.com', 'age': 25},     key_columns=['email'] )</p> Source code in <code>synthdb/connection.py</code> <pre><code>def upsert(self, table_name: str, data: Dict[str, Any], key_columns: List[str],\n           row_id: int = None) -&gt; int:\n    \"\"\"\n    Insert or update data based on key columns.\n\n    Args:\n        table_name: Name of the table\n        data: Column data to insert/update\n        key_columns: Columns to use for matching existing rows\n        row_id: Explicit row ID for new inserts (ignored for updates)\n\n    Returns:\n        Row ID of inserted or updated row\n\n    Examples:\n        # Insert new user or update if email exists\n        user_id = db.upsert('users', \n            {'name': 'John', 'email': 'john@example.com', 'age': 25},\n            key_columns=['email']\n        )\n    \"\"\"\n    from .api import upsert\n    return upsert(table_name, data, key_columns, self.connection_info, \n                 self.backend_name, row_id)\n</code></pre>"},{"location":"api/connection/#factory-function","title":"Factory Function","text":""},{"location":"api/connection/#synthdb.connect","title":"<code>synthdb.connect(connection_info='db.db', backend=None, auto_init=True)</code>","text":"<p>Create a SynthDB connection.</p> <p>This is the primary way to connect to a SynthDB database.</p> <p>Parameters:</p> Name Type Description Default <code>connection_info</code> <code>Union[str, Dict[str, Any]]</code> <p>Database file path or dict</p> <code>'db.db'</code> <code>backend</code> <code>str</code> <p>Database backend ('limbo', 'sqlite')</p> <code>None</code> <code>auto_init</code> <code>bool</code> <p>Automatically initialize database if it doesn't exist</p> <code>True</code> <p>Returns:</p> Type Description <code>Connection</code> <p>Connection instance</p> <p>Examples:</p>"},{"location":"api/connection/#synthdb.connect--quick-connection","title":"Quick connection","text":"<p>db = synthdb.connect('myapp.db', 'sqlite')</p>"},{"location":"api/connection/#synthdb.connect--auto-detect-backend","title":"Auto-detect backend","text":"<p>db = synthdb.connect('app.db')</p> Source code in <code>synthdb/connection.py</code> <pre><code>def connect(connection_info: Union[str, Dict[str, Any]] = 'db.db', \n           backend: str = None, auto_init: bool = True) -&gt; Connection:\n    \"\"\"\n    Create a SynthDB connection.\n\n    This is the primary way to connect to a SynthDB database.\n\n    Args:\n        connection_info: Database file path or dict\n        backend: Database backend ('limbo', 'sqlite')\n        auto_init: Automatically initialize database if it doesn't exist\n\n    Returns:\n        Connection instance\n\n    Examples:\n        # Quick connection\n        db = synthdb.connect('myapp.db', 'sqlite')\n\n        # Auto-detect backend\n        db = synthdb.connect('app.db')\n    \"\"\"\n    return Connection(connection_info, backend, auto_init)\n</code></pre>"},{"location":"api/connection/#connection-methods","title":"Connection Methods","text":""},{"location":"api/connection/#table-management","title":"Table Management","text":""},{"location":"api/connection/#create_table","title":"create_table()","text":"<p>Create a new table.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Table name</p> required <p>Returns:</p> Type Description <code>int</code> <p>Table ID</p> Source code in <code>synthdb/connection.py</code> <pre><code>def create_table(self, name: str) -&gt; int:\n    \"\"\"\n    Create a new table.\n\n    Args:\n        name: Table name\n\n    Returns:\n        Table ID\n    \"\"\"\n    return _create_table(name, self.connection_info, self.backend_name)\n</code></pre>"},{"location":"api/connection/#add_column","title":"add_column()","text":"<p>Add a single column to a table.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>Name of the table</p> required <code>column_name</code> <code>str</code> <p>Name of the column</p> required <code>data_type</code> <code>str</code> <p>Data type ('text', 'integer', 'real', 'boolean', 'json', 'timestamp')</p> required <p>Returns:</p> Type Description <code>int</code> <p>Column ID</p> Source code in <code>synthdb/connection.py</code> <pre><code>def add_column(self, table_name: str, column_name: str, data_type: str) -&gt; int:\n    \"\"\"\n    Add a single column to a table.\n\n    Args:\n        table_name: Name of the table\n        column_name: Name of the column\n        data_type: Data type ('text', 'integer', 'real', 'boolean', 'json', 'timestamp')\n\n    Returns:\n        Column ID\n    \"\"\"\n    return _add_column(table_name, column_name, data_type, \n                      self.connection_info, self.backend_name)\n</code></pre>"},{"location":"api/connection/#add_columns","title":"add_columns()","text":"<p>Add multiple columns to a table at once with type inference.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>Name of the table</p> required <code>columns</code> <code>Dict[str, Union[str, Any]]</code> <p>Dictionary of column_name -&gt; type_or_sample_value</p> required <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Dictionary mapping column names to their IDs</p> <p>Examples:</p>"},{"location":"api/connection/#synthdb.Connection.add_columns--explicit-types","title":"Explicit types","text":"<p>ids = db.add_columns('users', {     'email': 'text',     'created_at': 'timestamp',     'metadata': 'json' })</p>"},{"location":"api/connection/#synthdb.Connection.add_columns--inferred-types-from-sample-values","title":"Inferred types from sample values","text":"<p>ids = db.add_columns('users', {     'email': 'user@example.com',      # -&gt; text     'age': 25,                        # -&gt; integer     'active': True,                   # -&gt; boolean     'created_at': '2023-12-25'        # -&gt; timestamp })</p> Source code in <code>synthdb/connection.py</code> <pre><code>def add_columns(self, table_name: str, columns: Dict[str, Union[str, Any]]) -&gt; Dict[str, int]:\n    \"\"\"\n    Add multiple columns to a table at once with type inference.\n\n    Args:\n        table_name: Name of the table\n        columns: Dictionary of column_name -&gt; type_or_sample_value\n\n    Returns:\n        Dictionary mapping column names to their IDs\n\n    Examples:\n        # Explicit types\n        ids = db.add_columns('users', {\n            'email': 'text',\n            'created_at': 'timestamp',\n            'metadata': 'json'\n        })\n\n        # Inferred types from sample values\n        ids = db.add_columns('users', {\n            'email': 'user@example.com',      # -&gt; text\n            'age': 25,                        # -&gt; integer\n            'active': True,                   # -&gt; boolean\n            'created_at': '2023-12-25'        # -&gt; timestamp\n        })\n    \"\"\"\n    valid_types = {\"text\", \"integer\", \"real\", \"boolean\", \"json\", \"timestamp\"}\n    column_ids = {}\n\n    with transaction_context(self.connection_info, self.backend_name) as (backend, connection):\n        for col_name, type_or_value in columns.items():\n            # Determine if it's a type name or sample value\n            if isinstance(type_or_value, str) and type_or_value in valid_types:\n                # It's an explicit type\n                data_type = type_or_value\n            else:\n                # It's a sample value - infer the type\n                data_type, _ = infer_type(type_or_value)\n\n            # Add the column using transaction context\n            column_id = _add_column(\n                table_name, col_name, data_type, self.connection_info, self.backend_name,\n                backend=backend, connection=connection\n            )\n            column_ids[col_name] = column_id\n\n    # Recreate views to include new columns\n    create_table_views(self.connection_info, self.backend_name)\n\n    return column_ids\n</code></pre>"},{"location":"api/connection/#data-operations","title":"Data Operations","text":""},{"location":"api/connection/#insert","title":"insert()","text":"<p>Insert data into a table with automatic or explicit ID management.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>Name of the table</p> required <code>data</code> <code>Union[Dict[str, Any], str]</code> <p>Dictionary of column-&gt;value pairs, OR column name (if value provided)</p> required <code>value</code> <code>Any</code> <p>Value to insert (if data is a column name)</p> <code>None</code> <code>force_type</code> <code>str</code> <p>Override automatic type inference</p> <code>None</code> <code>row_id</code> <code>int</code> <p>Explicit row ID (if None, auto-generates next available ID)</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The row ID (auto-generated or explicitly provided)</p> <p>Examples:</p>"},{"location":"api/connection/#synthdb.Connection.insert--auto-generated-id","title":"Auto-generated ID","text":"<p>user_id = db.insert('users', {'name': 'John', 'age': 25})</p>"},{"location":"api/connection/#synthdb.Connection.insert--explicit-id","title":"Explicit ID","text":"<p>db.insert('users', {'name': 'Jane'}, row_id=100)</p>"},{"location":"api/connection/#synthdb.Connection.insert--single-column","title":"Single column","text":"<p>db.insert('users', 'email', 'john@example.com')</p>"},{"location":"api/connection/#synthdb.Connection.insert--force-specific-type","title":"Force specific type","text":"<p>db.insert('users', 'age', '25', force_type='text')</p> Source code in <code>synthdb/connection.py</code> <pre><code>def insert(self, table_name: str, data: Union[Dict[str, Any], str], \n           value: Any = None, force_type: str = None, row_id: int = None) -&gt; int:\n    \"\"\"\n    Insert data into a table with automatic or explicit ID management.\n\n    Args:\n        table_name: Name of the table\n        data: Dictionary of column-&gt;value pairs, OR column name (if value provided)\n        value: Value to insert (if data is a column name)\n        force_type: Override automatic type inference\n        row_id: Explicit row ID (if None, auto-generates next available ID)\n\n    Returns:\n        The row ID (auto-generated or explicitly provided)\n\n    Examples:\n        # Auto-generated ID\n        user_id = db.insert('users', {'name': 'John', 'age': 25})\n\n        # Explicit ID\n        db.insert('users', {'name': 'Jane'}, row_id=100)\n\n        # Single column\n        db.insert('users', 'email', 'john@example.com')\n\n        # Force specific type\n        db.insert('users', 'age', '25', force_type='text')\n    \"\"\"\n    from .api import insert\n    return insert(table_name, data, value, self.connection_info, \n                 self.backend_name, force_type, row_id)\n</code></pre>"},{"location":"api/connection/#query","title":"query()","text":"<p>Query data from a table.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>Name of the table to query</p> required <code>where</code> <code>str</code> <p>Optional WHERE clause</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of dictionaries representing rows</p> <p>Examples:</p>"},{"location":"api/connection/#synthdb.Connection.query--get-all-rows","title":"Get all rows","text":"<p>rows = db.query('users')</p>"},{"location":"api/connection/#synthdb.Connection.query--filter-rows","title":"Filter rows","text":"<p>rows = db.query('users', 'age &gt; 25')</p> Source code in <code>synthdb/connection.py</code> <pre><code>def query(self, table_name: str, where: str = None) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Query data from a table.\n\n    Args:\n        table_name: Name of the table to query\n        where: Optional WHERE clause\n\n    Returns:\n        List of dictionaries representing rows\n\n    Examples:\n        # Get all rows\n        rows = db.query('users')\n\n        # Filter rows\n        rows = db.query('users', 'age &gt; 25')\n    \"\"\"\n    return query_view(table_name, where, self.connection_info, self.backend_name)\n</code></pre>"},{"location":"api/connection/#upsert","title":"upsert()","text":"<p>Insert or update data based on key columns.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>Name of the table</p> required <code>data</code> <code>Dict[str, Any]</code> <p>Column data to insert/update</p> required <code>key_columns</code> <code>List[str]</code> <p>Columns to use for matching existing rows</p> required <code>row_id</code> <code>int</code> <p>Explicit row ID for new inserts (ignored for updates)</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>Row ID of inserted or updated row</p> <p>Examples:</p>"},{"location":"api/connection/#synthdb.Connection.upsert--insert-new-user-or-update-if-email-exists","title":"Insert new user or update if email exists","text":"<p>user_id = db.upsert('users',      {'name': 'John', 'email': 'john@example.com', 'age': 25},     key_columns=['email'] )</p> Source code in <code>synthdb/connection.py</code> <pre><code>def upsert(self, table_name: str, data: Dict[str, Any], key_columns: List[str],\n           row_id: int = None) -&gt; int:\n    \"\"\"\n    Insert or update data based on key columns.\n\n    Args:\n        table_name: Name of the table\n        data: Column data to insert/update\n        key_columns: Columns to use for matching existing rows\n        row_id: Explicit row ID for new inserts (ignored for updates)\n\n    Returns:\n        Row ID of inserted or updated row\n\n    Examples:\n        # Insert new user or update if email exists\n        user_id = db.upsert('users', \n            {'name': 'John', 'email': 'john@example.com', 'age': 25},\n            key_columns=['email']\n        )\n    \"\"\"\n    from .api import upsert\n    return upsert(table_name, data, key_columns, self.connection_info, \n                 self.backend_name, row_id)\n</code></pre>"},{"location":"api/connection/#database-inspection","title":"Database Inspection","text":""},{"location":"api/connection/#list_tables","title":"list_tables()","text":"<p>List all tables in the database.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of table information dictionaries</p> Source code in <code>synthdb/connection.py</code> <pre><code>def list_tables(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    List all tables in the database.\n\n    Returns:\n        List of table information dictionaries\n    \"\"\"\n    return list_tables(self.connection_info, self.backend_name)\n</code></pre>"},{"location":"api/connection/#list_columns","title":"list_columns()","text":"<p>List all columns in a table.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>Name of the table</p> required <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of column information dictionaries</p> Source code in <code>synthdb/connection.py</code> <pre><code>def list_columns(self, table_name: str) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    List all columns in a table.\n\n    Args:\n        table_name: Name of the table\n\n    Returns:\n        List of column information dictionaries\n    \"\"\"\n    return list_columns(table_name, self.connection_info, self.backend_name)\n</code></pre>"},{"location":"api/connection/#refresh_views","title":"refresh_views()","text":"<p>Refresh all table views in the database.</p> Source code in <code>synthdb/connection.py</code> <pre><code>def refresh_views(self) -&gt; None:\n    \"\"\"\n    Refresh all table views in the database.\n    \"\"\"\n    create_table_views(self.connection_info, self.backend_name)\n</code></pre>"},{"location":"api/connection/#examples","title":"Examples","text":""},{"location":"api/connection/#basic-usage","title":"Basic Usage","text":"<pre><code>import synthdb\n\n# Create connection\ndb = synthdb.connect('example.limbo')  # Uses Limbo by default\n\n# Create table and add columns\ndb.create_table('products')\ndb.add_columns('products', {\n    'name': 'text',\n    'price': 19.99,  # Infers real type\n    'active': True   # Infers boolean type\n})\n\n# Insert data\nproduct_id = db.insert('products', {\n    'name': 'Widget',\n    'price': 29.99,\n    'active': True\n})\n\n# Query data\nproducts = db.query('products', 'active = \"true\"')\n</code></pre>"},{"location":"api/connection/#advanced-patterns","title":"Advanced Patterns","text":"<pre><code># Batch operations\nproducts = [\n    {'name': 'Widget A', 'price': 19.99},\n    {'name': 'Widget B', 'price': 29.99},\n    {'name': 'Widget C', 'price': 39.99},\n]\n\nfor product in products:\n    db.insert('products', product)\n\n# Upsert with key columns\ndb.upsert('products', {\n    'name': 'Widget A',\n    'price': 24.99,  # Updated price\n    'active': True\n}, key_columns=['name'])\n\n# Complex queries\nexpensive = db.query('products', 'price &gt; 25 AND active = \"true\"')\n</code></pre>"},{"location":"api/connection/#error-handling","title":"Error Handling","text":"<pre><code>try:\n    # Insert with explicit ID\n    db.insert('products', {'name': 'Test'}, row_id=1000)\n\n    # Try duplicate ID\n    db.insert('products', {'name': 'Test2'}, row_id=1000)\n\nexcept ValueError as e:\n    print(f\"Duplicate ID error: {e}\")\n\ntry:\n    # Query non-existent column\n    db.query('products', 'nonexistent = \"value\"')\n\nexcept Exception as e:\n    print(f\"Query error: {e}\")\n</code></pre>"},{"location":"api/connection/#connection-configuration","title":"Connection Configuration","text":""},{"location":"api/connection/#backend-selection","title":"Backend Selection","text":"<pre><code># Explicit backend selection\ndb_limbo = synthdb.connect('app.limbo')                    # Uses Limbo (default)\ndb_sqlite = synthdb.connect('app.db', backend='sqlite')     # Uses SQLite explicitly\n\n# Auto-detection by file extension\ndb_auto_limbo = synthdb.connect('app.limbo')   # Uses Limbo (recommended)\ndb_auto_sqlite = synthdb.connect('app.db')     # Uses SQLite\n</code></pre>"},{"location":"api/connection/#connection-options","title":"Connection Options","text":"<pre><code># Auto-initialization (default: True)\ndb = synthdb.connect('app.limbo', auto_init=True)\n\n# Manual initialization\ndb = synthdb.connect('app.limbo', auto_init=False)\n# ... perform setup operations ...\ndb.init_db()  # Call when ready\n</code></pre>"},{"location":"api/connection/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/connection/#batch-operations","title":"Batch Operations","text":"<p>For multiple inserts, consider batching:</p> <pre><code># Instead of individual inserts\nfor item in large_dataset:\n    db.insert('table', item)\n\n# Consider using upsert for updates\nfor item in large_dataset:\n    db.upsert('table', item, key_columns=['id'])\n</code></pre>"},{"location":"api/connection/#query-optimization","title":"Query Optimization","text":"<pre><code># Use specific WHERE clauses\nusers = db.query('users', 'active = \"true\" AND age &gt; 25')\n\n# Limit results when possible\nrecent_users = db.query('users', 'created_at &gt; \"2024-01-01\"')\n</code></pre>"},{"location":"api/connection/#connection-reuse","title":"Connection Reuse","text":"<pre><code># Reuse connections for multiple operations\ndb = synthdb.connect('app.limbo')\n\n# Multiple operations on same connection\ndb.create_table('users')\ndb.add_columns('users', {...})\ndb.insert('users', {...})\nresults = db.query('users')\n\n# No need to reconnect for each operation\n</code></pre>"},{"location":"api/connection/#see-also","title":"See Also","text":"<ul> <li>CLI Reference - Command-line interface</li> <li>Core Functions - Lower-level functions</li> <li>Examples - Real-world usage patterns</li> </ul>"},{"location":"development/feature-proposals/","title":"Feature Proposals","text":"<p>This section contains detailed proposals for new features and enhancements to SynthDB. Each proposal includes motivation, design details, implementation plans, and considerations for future development.</p>"},{"location":"development/feature-proposals/#current-proposals","title":"Current Proposals","text":""},{"location":"development/feature-proposals/#database-branching","title":"Database Branching","text":"Proposed <p>Database Branching</p> <p>Add branching capabilities to SynthDB, allowing users to create isolated copies of database files, perform operations on them, and optionally merge changes back to the main database.</p> <p>Key Features: - Create isolated database branches for safe experimentation - Merge changes back to main database with conflict resolution - Support for different branching strategies (copy, copy-on-write, read-only) - Git-like workflow for database operations</p> <p>Complexity: High | Timeline: 9-13 weeks</p>"},{"location":"development/feature-proposals/#joined-table-queries","title":"Joined Table Queries","text":"Proposed <p>Joined Table Queries</p> <p>Add support for joining multiple tables in SynthDB queries, enabling relational queries across the flexible schema-on-write architecture.</p> <p>Key Features: - Inner, left, right, and outer joins - Automatic relationship detection and predefined joins - Join builder pattern for complex queries - Integration with SynthDB's EAV model</p> <p>Complexity: Medium | Timeline: 8-12 weeks</p>"},{"location":"development/feature-proposals/#safe-user-query-execution","title":"Safe User Query Execution","text":"Proposed <p>Safe User Query Execution</p> <p>Add the ability for users to execute custom SQL queries with built-in safety mechanisms that prevent modification of database structure or access to internal tables.</p> <p>Key Features: - SQL parsing and validation for safety - Read-only query execution with security controls - Advanced analytics capabilities (window functions, CTEs) - Integration with reporting tools and BI systems</p> <p>Complexity: Medium | Timeline: 10-14 weeks</p>"},{"location":"development/feature-proposals/#proposal-process","title":"Proposal Process","text":""},{"location":"development/feature-proposals/#submitting-a-proposal","title":"Submitting a Proposal","text":"<ol> <li>Research: Review existing functionality and similar features in other systems</li> <li>Template: Use the proposal template for consistency</li> <li>Discussion: Share with the development team for initial feedback</li> <li>Refinement: Iterate on the design based on feedback</li> <li>Documentation: Submit complete proposal as a pull request</li> </ol>"},{"location":"development/feature-proposals/#proposal-lifecycle","title":"Proposal Lifecycle","text":"<pre><code>graph LR\n    A[Draft] --&gt; B[Proposed]\n    B --&gt; C[Under Review]\n    C --&gt; D[Accepted]\n    C --&gt; E[Rejected]\n    D --&gt; F[In Progress]\n    F --&gt; G[Implemented]\n    F --&gt; H[On Hold]\n    H --&gt; F</code></pre>"},{"location":"development/feature-proposals/#status-definitions","title":"Status Definitions","text":"<ul> <li>Proposed: Initial proposal submitted, awaiting review</li> <li>Under Review: Being evaluated by the development team</li> <li>Accepted: Approved for implementation, waiting for scheduling</li> <li>In Progress: Currently being implemented</li> <li>On Hold: Implementation paused due to dependencies or priorities</li> <li>Implemented: Feature completed and merged</li> <li>Rejected: Not approved for implementation</li> </ul>"},{"location":"development/feature-proposals/#evaluation-criteria","title":"Evaluation Criteria","text":"<p>Proposals are evaluated based on:</p> <ol> <li>User Value: Does this solve real user problems?</li> <li>Technical Feasibility: Can this be implemented with reasonable effort?</li> <li>Architectural Fit: Does this align with SynthDB's design principles?</li> <li>Maintenance Burden: What's the long-term maintenance cost?</li> <li>Breaking Changes: Does this require breaking changes to existing APIs?</li> <li>Performance Impact: How does this affect system performance?</li> </ol>"},{"location":"development/feature-proposals/#implementation-priorities","title":"Implementation Priorities","text":""},{"location":"development/feature-proposals/#high-priority","title":"High Priority","text":"<p>Features that address core user needs and align with SynthDB's mission: - Enhanced query capabilities - Data integrity and safety features - Performance improvements - Developer experience enhancements</p>"},{"location":"development/feature-proposals/#medium-priority","title":"Medium Priority","text":"<p>Features that add significant value but are not critical: - Advanced analytical capabilities - Integration features - Workflow improvements - Specialized use case support</p>"},{"location":"development/feature-proposals/#low-priority","title":"Low Priority","text":"<p>Features that are nice-to-have but not essential: - Experimental features - Niche use cases - Convenience features - Cosmetic improvements</p>"},{"location":"development/feature-proposals/#contributing-to-proposals","title":"Contributing to Proposals","text":""},{"location":"development/feature-proposals/#for-users","title":"For Users","text":"<ul> <li>Feature Requests: Submit issues describing features you need</li> <li>Use Cases: Share real-world scenarios where features would help</li> <li>Feedback: Comment on existing proposals with your perspective</li> <li>Testing: Help test proposed features during development</li> </ul>"},{"location":"development/feature-proposals/#for-developers","title":"For Developers","text":"<ul> <li>Design Reviews: Participate in proposal discussions</li> <li>Implementation: Take ownership of approved proposals</li> <li>Prototyping: Create proof-of-concept implementations</li> <li>Documentation: Help refine proposal documentation</li> </ul>"},{"location":"development/feature-proposals/#related-documentation","title":"Related Documentation","text":"<ul> <li>Contributing Guide - How to contribute to SynthDB</li> <li>Architecture Overview - Understanding SynthDB's design</li> <li>Development Setup - Setting up for development</li> </ul>"},{"location":"development/feature-proposals/#questions-and-discussion","title":"Questions and Discussion","text":"<p>Have questions about these proposals or ideas for new features?</p> <ul> <li>GitHub Discussions: Start a discussion</li> <li>Issues: Create an issue for specific feature requests</li> <li>Pull Requests: Submit proposal documents as pull requests</li> </ul> <p>Last updated: 2024-06-26</p>"},{"location":"development/feature-proposals/database-branching/","title":"Feature Proposal: Database Branching","text":"Proposed <p>Authors: SynthDB Development Team Created: 2024-06-26 Status: Proposal Complexity: High  </p>"},{"location":"development/feature-proposals/database-branching/#summary","title":"Summary","text":"<p>Add branching capabilities to SynthDB, allowing users to create isolated copies of database files, perform operations on them, and optionally merge changes back to the main database. This would enable safe experimentation, parallel development workflows, and atomic multi-operation transactions.</p>"},{"location":"development/feature-proposals/database-branching/#motivation","title":"Motivation","text":""},{"location":"development/feature-proposals/database-branching/#use-cases","title":"Use Cases","text":"<ol> <li>Experimental Development: Test schema changes or data transformations without affecting production data</li> <li>Parallel Workflows: Multiple developers or processes working on different features simultaneously</li> <li>Atomic Complex Operations: Perform multiple related operations that should succeed or fail together</li> <li>Rollback Scenarios: Easy rollback to previous states before applying risky operations</li> <li>A/B Testing: Compare different data processing approaches on the same dataset</li> <li>Backup and Restore: Create point-in-time snapshots for recovery</li> </ol>"},{"location":"development/feature-proposals/database-branching/#current-limitations","title":"Current Limitations","text":"<ul> <li>All operations are performed directly on the main database file</li> <li>No way to test operations without affecting live data</li> <li>Complex multi-step operations can leave database in inconsistent state if interrupted</li> <li>No built-in backup/restore mechanism</li> </ul>"},{"location":"development/feature-proposals/database-branching/#detailed-design","title":"Detailed Design","text":""},{"location":"development/feature-proposals/database-branching/#core-concepts","title":"Core Concepts","text":""},{"location":"development/feature-proposals/database-branching/#branch","title":"Branch","text":"<p>A branch is an independent copy of a database file that can be modified without affecting the original. Branches maintain metadata about their origin and changes.</p>"},{"location":"development/feature-proposals/database-branching/#branch-types","title":"Branch Types","text":"<ol> <li>Feature Branch: Full copy for development work</li> <li>Snapshot Branch: Read-only copy for backup/analysis</li> <li>Temporary Branch: Auto-deleted after session</li> <li>Merge Branch: Specifically for merging changes</li> </ol>"},{"location":"development/feature-proposals/database-branching/#api-design","title":"API Design","text":""},{"location":"development/feature-proposals/database-branching/#core-branch-operations","title":"Core Branch Operations","text":"<pre><code>import synthdb\n\n# Create main connection\nmain_db = synthdb.connect('app.limbo')  # Uses Limbo by default\n\n# Create a branch\nbranch_db = main_db.create_branch('feature-user-profiles')\n# or\nbranch_db = main_db.branch('feature-user-profiles')\n\n# Work on the branch\nbranch_db.create_table('user_profiles')\nbranch_db.add_columns('user_profiles', {'bio': 'text', 'avatar': 'text'})\n\n# List branches\nbranches = main_db.list_branches()\n# Returns: [{'name': 'feature-user-profiles', 'created_at': '...', 'size': '...'}]\n\n# Switch between branches\ncurrent_branch = main_db.get_current_branch()  # 'main'\nmain_db.checkout_branch('feature-user-profiles')\n\n# Merge branch back to main\nmerge_result = main_db.merge_branch('feature-user-profiles')\n# Returns: {'success': True, 'conflicts': [], 'changes_applied': 15}\n\n# Delete branch\nmain_db.delete_branch('feature-user-profiles')\n</code></pre>"},{"location":"development/feature-proposals/database-branching/#advanced-branch-operations","title":"Advanced Branch Operations","text":"<pre><code># Create branch from specific point in time\nbranch_db = main_db.create_branch('rollback-test', from_timestamp='2024-06-25 10:00:00')\n\n# Create branch with copy strategy\nbranch_db = main_db.create_branch('experiment', strategy='copy')  # Full copy\nbranch_db = main_db.create_branch('snapshot', strategy='readonly')  # Read-only reference\n\n# Branch with auto-cleanup\nwith main_db.temporary_branch('temp-operations') as temp_db:\n    temp_db.insert('users', {'name': 'test'})\n    # Branch automatically deleted when exiting context\n\n# Compare branches\ndiff = main_db.compare_branches('main', 'feature-user-profiles')\n# Returns detailed diff of schema and data changes\n</code></pre>"},{"location":"development/feature-proposals/database-branching/#implementation-architecture","title":"Implementation Architecture","text":""},{"location":"development/feature-proposals/database-branching/#file-system-structure","title":"File System Structure","text":"<pre><code>app.db                    # Main database file\n.synthdb/\n  branches/\n    feature-user-profiles.db     # Branch database file\n    experiment.db                # Another branch\n  metadata/\n    branches.json               # Branch metadata\n    main.json                  # Main database metadata\n  locks/\n    feature-user-profiles.lock  # Branch locks for concurrent access\n</code></pre>"},{"location":"development/feature-proposals/database-branching/#metadata-schema","title":"Metadata Schema","text":"<pre><code># branches.json structure\n{\n  \"branches\": {\n    \"feature-user-profiles\": {\n      \"created_at\": \"2024-06-26T10:00:00Z\",\n      \"created_from\": \"main\",\n      \"strategy\": \"copy\",\n      \"size_bytes\": 1048576,\n      \"last_modified\": \"2024-06-26T11:30:00Z\",\n      \"description\": \"Adding user profile features\",\n      \"auto_delete\": false\n    }\n  },\n  \"main\": {\n    \"file\": \"app.db\",\n    \"last_branched\": \"2024-06-26T10:00:00Z\"\n  }\n}\n</code></pre>"},{"location":"development/feature-proposals/database-branching/#branch-strategies","title":"Branch Strategies","text":"<ol> <li>Full Copy (<code>copy</code>)</li> <li>Complete file copy</li> <li>Independent operations</li> <li>Higher disk usage</li> <li> <p>Safest option</p> </li> <li> <p>Copy-on-Write (<code>cow</code>)</p> </li> <li>Shared data, separate changes</li> <li>More complex implementation</li> <li>Better disk efficiency</li> <li> <p>Requires filesystem support</p> </li> <li> <p>Read-Only Reference (<code>readonly</code>)</p> </li> <li>Shared file access</li> <li>No modifications allowed</li> <li>Minimal overhead</li> <li>Good for snapshots</li> </ol>"},{"location":"development/feature-proposals/database-branching/#merge-strategies","title":"Merge Strategies","text":""},{"location":"development/feature-proposals/database-branching/#simple-merge-non-conflicting","title":"Simple Merge (Non-Conflicting)","text":"<ul> <li>Schema additions (new tables, columns)</li> <li>Data additions (new rows with unique IDs)</li> <li>Compatible data type changes</li> </ul>"},{"location":"development/feature-proposals/database-branching/#conflict-resolution","title":"Conflict Resolution","text":"<ul> <li>Schema conflicts (same column, different types)</li> <li>Data conflicts (same row ID, different values)</li> <li>Deletion conflicts (data deleted in one branch, modified in another)</li> </ul> <pre><code># Manual conflict resolution\nconflicts = main_db.merge_branch('feature-branch', dry_run=True)\nfor conflict in conflicts:\n    if conflict.type == 'schema_conflict':\n        # Choose resolution strategy\n        conflict.resolve('prefer_branch')  # or 'prefer_main', 'manual'\n    elif conflict.type == 'data_conflict':\n        # Provide resolution data\n        conflict.resolve_with_data({'column': 'new_value'})\n\n# Apply merge with resolutions\nmerge_result = main_db.merge_branch('feature-branch', conflicts=conflicts)\n</code></pre>"},{"location":"development/feature-proposals/database-branching/#cli-integration","title":"CLI Integration","text":"<pre><code># Branch operations\nsdb branch create feature-auth\nsdb branch list\nsdb branch switch feature-auth\nsdb branch delete feature-auth\n\n# Work on branches\nsdb branch create experiment\nsdb --branch experiment table create test_table\nsdb --branch experiment add test_table '{\"name\": \"test\"}'\n\n# Merge operations\nsdb branch merge feature-auth\nsdb branch merge feature-auth --dry-run\nsdb branch diff main feature-auth\n\n# Snapshot operations\nsdb branch snapshot backup-before-migration\nsdb branch restore backup-before-migration\n</code></pre>"},{"location":"development/feature-proposals/database-branching/#implementation-plan","title":"Implementation Plan","text":""},{"location":"development/feature-proposals/database-branching/#phase-1-basic-branching-4-6-weeks","title":"Phase 1: Basic Branching (4-6 weeks)","text":"<ul> <li> File copying mechanism</li> <li> Branch metadata management</li> <li> Basic create/switch/delete operations</li> <li> CLI integration</li> <li> Simple merge (non-conflicting)</li> </ul>"},{"location":"development/feature-proposals/database-branching/#phase-2-advanced-features-3-4-weeks","title":"Phase 2: Advanced Features (3-4 weeks)","text":"<ul> <li> Conflict detection and resolution</li> <li> Branch comparison and diff</li> <li> Temporary branches</li> <li> Copy-on-write strategy</li> </ul>"},{"location":"development/feature-proposals/database-branching/#phase-3-production-features-2-3-weeks","title":"Phase 3: Production Features (2-3 weeks)","text":"<ul> <li> Concurrent access handling</li> <li> Performance optimization</li> <li> Advanced merge strategies</li> <li> Documentation and examples</li> </ul>"},{"location":"development/feature-proposals/database-branching/#considerations","title":"Considerations","text":""},{"location":"development/feature-proposals/database-branching/#performance","title":"Performance","text":"<ul> <li>File Copy Overhead: Large databases will have slow branch creation</li> <li>Disk Space: Multiple branches can consume significant storage</li> <li>Merge Complexity: Large diffs may be slow to process</li> </ul> <p>Mitigations: - Implement copy-on-write for supported filesystems - Add disk usage monitoring and warnings - Provide progress indicators for long operations - Implement incremental/streaming merges</p>"},{"location":"development/feature-proposals/database-branching/#concurrency","title":"Concurrency","text":"<ul> <li>Branch Access: Multiple connections to same branch</li> <li>Merge Conflicts: Concurrent modifications during merge</li> <li>File Locking: Platform-specific file locking mechanisms</li> </ul> <p>Mitigations: - Implement branch-level locking - Use atomic file operations - Provide clear error messages for lock conflicts</p>"},{"location":"development/feature-proposals/database-branching/#data-integrity","title":"Data Integrity","text":"<ul> <li>Partial Merges: Ensure atomic merge operations</li> <li>Corruption: Protect against file corruption during operations</li> <li>Metadata Consistency: Keep branch metadata in sync with actual files</li> </ul> <p>Mitigations: - Use database transactions for merge operations - Implement checksum verification - Regular metadata validation</p>"},{"location":"development/feature-proposals/database-branching/#alternative-approaches","title":"Alternative Approaches","text":""},{"location":"development/feature-proposals/database-branching/#1-transaction-based-approach","title":"1. Transaction-Based Approach","text":"<p>Instead of file-level branching, use database transactions with savepoints.</p> <p>Pros:  - No file copying overhead - Native database support - Better performance</p> <p>Cons:  - Limited by database transaction capabilities - No persistent branches - Complex rollback scenarios</p>"},{"location":"development/feature-proposals/database-branching/#2-schema-versioning","title":"2. Schema Versioning","text":"<p>Track schema changes and data migrations without full branching.</p> <p>Pros:  - Lightweight implementation - Good for schema evolution - Fits existing SynthDB architecture</p> <p>Cons:  - Limited to schema changes - No data experimentation - Complex conflict resolution</p>"},{"location":"development/feature-proposals/database-branching/#3-virtual-branching","title":"3. Virtual Branching","text":"<p>Use overlays and views instead of physical copies.</p> <p>Pros:  - No disk overhead - Fast branch creation - Complex query optimization</p> <p>Cons:  - Very complex implementation - Performance overhead on queries - Limited by SQL capabilities</p>"},{"location":"development/feature-proposals/database-branching/#success-metrics","title":"Success Metrics","text":"<ul> <li>Usability: Branch operations complete in &lt;5 seconds for databases &lt;100MB</li> <li>Reliability: 99.9% success rate for merge operations without conflicts</li> <li>Performance: &lt;10% overhead for operations on branched databases</li> <li>Adoption: Feature used in &gt;30% of SynthDB projects within 6 months</li> </ul>"},{"location":"development/feature-proposals/database-branching/#future-enhancements","title":"Future Enhancements","text":"<ul> <li>Remote Branches: Sync branches across multiple machines</li> <li>Automated Merging: AI-assisted conflict resolution</li> <li>Branch Templates: Predefined branch configurations</li> <li>Integration: Git-like workflow with external version control</li> <li>Compression: Efficient storage for similar branches</li> </ul>"},{"location":"development/feature-proposals/database-branching/#related-work","title":"Related Work","text":"<ul> <li>Git: File-based version control inspiration</li> <li>SQLite Backup API: Technical implementation reference  </li> <li>Database Replication: Multi-master conflict resolution patterns</li> <li>Copy-on-Write Filesystems: ZFS, Btrfs implementation examples</li> </ul>"},{"location":"development/feature-proposals/database-branching/#conclusion","title":"Conclusion","text":"<p>Database branching would significantly enhance SynthDB's utility for development, testing, and production workflows. While implementation is complex, the benefits for safe experimentation and parallel development justify the effort.</p> <p>The proposed design balances functionality with implementation complexity, providing a foundation for both simple use cases and advanced workflows. Starting with basic file copying and expanding to more sophisticated strategies allows for iterative development and user feedback integration.</p>"},{"location":"development/feature-proposals/joined-table-queries/","title":"Feature Proposal: Joined Table Queries","text":"Proposed <p>Authors: SynthDB Development Team Created: 2024-06-26 Status: Proposal Complexity: Medium  </p>"},{"location":"development/feature-proposals/joined-table-queries/#summary","title":"Summary","text":"<p>Add support for joining multiple tables in SynthDB queries, enabling relational queries across the flexible schema-on-write architecture. This would allow users to perform complex analytical queries while maintaining SynthDB's dynamic schema benefits.</p>"},{"location":"development/feature-proposals/joined-table-queries/#motivation","title":"Motivation","text":""},{"location":"development/feature-proposals/joined-table-queries/#use-cases","title":"Use Cases","text":"<ol> <li>Relational Analysis: Query related data across multiple tables</li> <li>Reporting: Generate reports combining data from multiple entities</li> <li>Data Exploration: Discover relationships between different data sets</li> <li>Migration from SQL: Easier transition for users familiar with SQL joins</li> <li>Complex Filtering: Filter one table based on conditions in related tables</li> </ol>"},{"location":"development/feature-proposals/joined-table-queries/#current-limitations","title":"Current Limitations","text":"<ul> <li>Queries are limited to single tables</li> <li>Related data must be manually fetched and combined in application code</li> <li>No way to leverage relationships between tables in queries</li> <li>Difficult to perform complex analytical operations</li> </ul>"},{"location":"development/feature-proposals/joined-table-queries/#example-scenarios","title":"Example Scenarios","text":"<pre><code># Current approach (manual joining in code)\nusers = db.query('users', 'active = \"true\"')\norders = db.query('orders')\nuser_orders = []\nfor user in users:\n    user_id = user['row_id']\n    user_order_list = [o for o in orders if o['user_id'] == user_id]\n    user_orders.append({'user': user, 'orders': user_order_list})\n\n# Desired approach (joined queries)\nuser_orders = db.query_joined([\n    ('users', 'u'),\n    ('orders', 'o', 'u.row_id = o.user_id')\n], 'u.active = \"true\"')\n</code></pre>"},{"location":"development/feature-proposals/joined-table-queries/#detailed-design","title":"Detailed Design","text":""},{"location":"development/feature-proposals/joined-table-queries/#core-concepts","title":"Core Concepts","text":""},{"location":"development/feature-proposals/joined-table-queries/#join-types","title":"Join Types","text":"<ol> <li>Inner Join: Only rows with matches in both tables</li> <li>Left Join: All rows from left table, with or without matches</li> <li>Right Join: All rows from right table, with or without matches  </li> <li>Full Outer Join: All rows from both tables</li> <li>Cross Join: Cartesian product of both tables</li> </ol>"},{"location":"development/feature-proposals/joined-table-queries/#join-conditions","title":"Join Conditions","text":"<ul> <li>Explicit: User-specified join conditions</li> <li>Implicit: Automatic detection based on common column names</li> <li>Composite: Multiple column joins</li> </ul>"},{"location":"development/feature-proposals/joined-table-queries/#api-design","title":"API Design","text":""},{"location":"development/feature-proposals/joined-table-queries/#connection-api-integration","title":"Connection API Integration","text":"<pre><code>import synthdb\n\ndb = synthdb.connect('app.limbo')  # Uses Limbo by default\n\n# Simple join syntax\nresult = db.query_joined('users', 'orders', on='users.row_id = orders.user_id')\n\n# Multiple table joins with aliases\nresult = db.query_joined([\n    ('users', 'u'),\n    ('orders', 'o', 'u.row_id = o.user_id'),\n    ('products', 'p', 'o.product_id = p.row_id')\n], where='u.active = \"true\" AND p.price &gt; 100')\n\n# Different join types\nresult = db.query_joined([\n    ('users', 'u'),\n    ('orders', 'o', 'u.row_id = o.user_id', 'LEFT')\n])\n\n# Aggregation with joins\nresult = db.query_joined([\n    ('users', 'u'),\n    ('orders', 'o', 'u.row_id = o.user_id')\n], select='u.name, COUNT(o.row_id) as order_count', group_by='u.row_id')\n</code></pre>"},{"location":"development/feature-proposals/joined-table-queries/#join-builder-pattern","title":"Join Builder Pattern","text":"<pre><code># Fluent interface for complex joins\nquery = (db.join_query()\n    .from_table('users', 'u')\n    .inner_join('orders', 'o', 'u.row_id = o.user_id')\n    .left_join('profiles', 'p', 'u.row_id = p.user_id')\n    .where('u.active = \"true\"')\n    .select('u.name', 'u.email', 'COUNT(o.row_id) as order_count', 'p.bio')\n    .group_by('u.row_id')\n    .order_by('order_count DESC')\n    .limit(10))\n\nresult = query.execute()\n</code></pre>"},{"location":"development/feature-proposals/joined-table-queries/#relationship-definition","title":"Relationship Definition","text":"<pre><code># Define relationships for automatic joins\ndb.define_relationship('users', 'orders', 'row_id', 'user_id', name='user_orders')\ndb.define_relationship('orders', 'products', 'product_id', 'row_id', name='order_products')\n\n# Use predefined relationships\nresult = db.query_with_relationships('users', include=['orders', 'orders.products'])\n# Automatically joins based on defined relationships\n</code></pre>"},{"location":"development/feature-proposals/joined-table-queries/#implementation-architecture","title":"Implementation Architecture","text":""},{"location":"development/feature-proposals/joined-table-queries/#query-translation","title":"Query Translation","text":"<p>SynthDB's EAV model requires special handling for joins:</p> <pre><code>-- Traditional SQL join\nSELECT u.name, o.total \nFROM users u \nJOIN orders o ON u.id = o.user_id\n\n-- SynthDB EAV translation\nSELECT \n    u_name.value as user_name,\n    o_total.value as order_total\nFROM table_definitions td_users\nJOIN text_values u_name ON td_users.id = u_name.table_id\nJOIN column_definitions cd_u_name ON u_name.column_id = cd_u_name.id AND cd_u_name.name = 'name'\nJOIN table_definitions td_orders\nJOIN real_values o_total ON td_orders.id = o_total.table_id  \nJOIN column_definitions cd_o_total ON o_total.column_id = cd_o_total.id AND cd_o_total.name = 'total'\nWHERE td_users.name = 'users' \n  AND td_orders.name = 'orders'\n  AND u_name.row_id = o_total.row_id  -- This is the actual join condition\n</code></pre>"},{"location":"development/feature-proposals/joined-table-queries/#virtual-view-generation","title":"Virtual View Generation","text":"<p>Create temporary views that present joined data in tabular format:</p> <pre><code>class JoinQuery:\n    def __init__(self, connection):\n        self.connection = connection\n        self.tables = []\n        self.joins = []\n        self.conditions = []\n\n    def create_join_view(self):\n        # Generate SQL for creating a temporary view\n        # that represents the joined data\n        view_sql = self._build_join_sql()\n        view_name = f\"temp_join_{uuid.uuid4().hex[:8]}\"\n\n        self.connection.execute(f\"CREATE TEMP VIEW {view_name} AS {view_sql}\")\n        return view_name\n\n    def execute(self):\n        view_name = self.create_join_view()\n        try:\n            return self.connection.query_view(view_name)\n        finally:\n            self.connection.execute(f\"DROP VIEW {view_name}\")\n</code></pre>"},{"location":"development/feature-proposals/joined-table-queries/#join-optimization","title":"Join Optimization","text":"<ol> <li>Predicate Pushdown: Move WHERE conditions closer to table scans</li> <li>Index Usage: Leverage existing indexes on row_id columns</li> <li>View Caching: Cache frequently used join patterns</li> <li>Statistics: Collect statistics for join optimization</li> </ol>"},{"location":"development/feature-proposals/joined-table-queries/#implementation-challenges","title":"Implementation Challenges","text":""},{"location":"development/feature-proposals/joined-table-queries/#eav-model-complexity","title":"EAV Model Complexity","text":"<p>SynthDB's Entity-Attribute-Value model makes joins complex:</p> <ul> <li>Multiple Value Tables: Each data type has its own table</li> <li>Dynamic Schema: Column structure not known at query time</li> <li>Row Reconstruction: Need to aggregate values back into rows</li> </ul> <p>Solution: Generate dynamic SQL that unions across value tables:</p> <pre><code>def build_table_query(table_name, alias, columns=None):\n    \"\"\"Build a query that reconstructs a table from EAV format.\"\"\"\n    if columns is None:\n        columns = self.list_columns(table_name)\n\n    # Build CASE statements for each column\n    select_clauses = []\n    for column in columns:\n        data_type = column['data_type']\n        table_suffix = f\"{data_type}_values\"\n\n        select_clauses.append(f\"\"\"\n            MAX(CASE WHEN cd.name = '{column['name']}' \n                THEN {table_suffix}.value END) as {column['name']}\n        \"\"\")\n\n    return f\"\"\"\n        SELECT \n            {alias}.row_id,\n            {', '.join(select_clauses)}\n        FROM table_definitions td\n        JOIN ({' UNION ALL '.join([\n            f\"SELECT table_id, column_id, row_id, value FROM {dt}_values\"\n            for dt in ['text', 'integer', 'real', 'boolean', 'json', 'timestamp']\n        ])}) vals ON td.id = vals.table_id\n        JOIN column_definitions cd ON vals.column_id = cd.id\n        WHERE td.name = '{table_name}'\n        GROUP BY {alias}.row_id\n    \"\"\"\n</code></pre>"},{"location":"development/feature-proposals/joined-table-queries/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Large Tables: Joins can be expensive with large datasets</li> <li>Index Strategy: Need appropriate indexes for join conditions</li> <li>Memory Usage: Temporary views may consume significant memory</li> </ul> <p>Mitigations: - Implement streaming joins for large datasets - Add query planning and optimization - Provide performance hints and warnings</p>"},{"location":"development/feature-proposals/joined-table-queries/#cli-integration","title":"CLI Integration","text":"<pre><code># Simple join queries\nsdb join users orders --on \"users.row_id = orders.user_id\"\n\n# Complex joins with multiple tables\nsdb join users,u orders,o products,p \\\n  --conditions \"u.row_id = o.user_id AND o.product_id = p.row_id\" \\\n  --where \"u.active = true AND p.price &gt; 100\" \\\n  --select \"u.name, p.name as product, o.quantity\"\n\n# Predefined relationship joins\nsdb join users --include orders,products --limit 10\n\n# Export joined results\nsdb join users orders --on \"users.row_id = orders.user_id\" \\\n  --format csv --output user_orders.csv\n</code></pre>"},{"location":"development/feature-proposals/joined-table-queries/#implementation-plan","title":"Implementation Plan","text":""},{"location":"development/feature-proposals/joined-table-queries/#phase-1-basic-joins-3-4-weeks","title":"Phase 1: Basic Joins (3-4 weeks)","text":"<ul> <li> Inner join implementation</li> <li> Simple join conditions (single column)</li> <li> Basic query translation from EAV to relational</li> <li> Connection API integration</li> <li> Unit tests for core functionality</li> </ul>"},{"location":"development/feature-proposals/joined-table-queries/#phase-2-advanced-join-types-2-3-weeks","title":"Phase 2: Advanced Join Types (2-3 weeks)","text":"<ul> <li> Left, right, and outer joins</li> <li> Multiple join conditions</li> <li> Join builder pattern API</li> <li> Performance optimization</li> <li> CLI integration</li> </ul>"},{"location":"development/feature-proposals/joined-table-queries/#phase-3-relationships-and-optimization-3-4-weeks","title":"Phase 3: Relationships and Optimization (3-4 weeks)","text":"<ul> <li> Relationship definition system</li> <li> Automatic join detection</li> <li> Query optimization</li> <li> Caching for frequently used joins</li> <li> Advanced error handling and validation</li> </ul>"},{"location":"development/feature-proposals/joined-table-queries/#phase-4-advanced-features-2-3-weeks","title":"Phase 4: Advanced Features (2-3 weeks)","text":"<ul> <li> Aggregation with joins</li> <li> Subqueries in join conditions</li> <li> Cross joins and complex patterns</li> <li> Performance monitoring and hints</li> <li> Documentation and examples</li> </ul>"},{"location":"development/feature-proposals/joined-table-queries/#api-examples","title":"API Examples","text":""},{"location":"development/feature-proposals/joined-table-queries/#basic-usage","title":"Basic Usage","text":"<pre><code># Setup test data\ndb = synthdb.connect('joined_queries_demo.db')\n\n# Create tables\ndb.create_table('users')\ndb.add_columns('users', {'name': 'text', 'email': 'text', 'active': True})\n\ndb.create_table('orders')\ndb.add_columns('orders', {'user_id': 1, 'total': 99.99, 'status': 'text'})\n\ndb.create_table('products')\ndb.add_columns('products', {'name': 'text', 'price': 29.99, 'category': 'text'})\n\n# Insert test data\nuser1 = db.insert('users', {'name': 'Alice', 'email': 'alice@test.com', 'active': True})\nuser2 = db.insert('users', {'name': 'Bob', 'email': 'bob@test.com', 'active': False})\n\norder1 = db.insert('orders', {'user_id': user1, 'total': 150.00, 'status': 'completed'})\norder2 = db.insert('orders', {'user_id': user1, 'total': 75.50, 'status': 'pending'})\norder3 = db.insert('orders', {'user_id': user2, 'total': 200.00, 'status': 'completed'})\n\n# Basic join query\nactive_user_orders = db.query_joined([\n    ('users', 'u'),\n    ('orders', 'o', 'u.row_id = o.user_id')\n], where='u.active = \"true\"')\n\nprint(f\"Active users with orders: {len(active_user_orders)}\")\n</code></pre>"},{"location":"development/feature-proposals/joined-table-queries/#advanced-usage","title":"Advanced Usage","text":"<pre><code># Complex multi-table join with aggregation\nuser_stats = db.query_joined([\n    ('users', 'u'),\n    ('orders', 'o', 'u.row_id = o.user_id', 'LEFT')\n], \nselect='u.name, u.email, COUNT(o.row_id) as order_count, SUM(o.total) as total_spent',\ngroup_by='u.row_id',\nhaving='order_count &gt; 0',\norder_by='total_spent DESC')\n\n# Relationship-based joins\ndb.define_relationship('users', 'orders', 'row_id', 'user_id')\ndb.define_relationship('orders', 'order_items', 'row_id', 'order_id')\ndb.define_relationship('order_items', 'products', 'product_id', 'row_id')\n\n# Query with nested relationships\nuser_purchases = db.query_with_relationships('users', \n    include=['orders.order_items.products'],\n    where='users.active = \"true\"')\n</code></pre>"},{"location":"development/feature-proposals/joined-table-queries/#performance-benchmarks","title":"Performance Benchmarks","text":"<p>Target performance characteristics: - Small joins (&lt;1000 rows per table): &lt;100ms - Medium joins (&lt;10,000 rows per table): &lt;1 second - Large joins (&lt;100,000 rows per table): &lt;10 seconds - Memory usage: &lt;2x size of largest table involved</p>"},{"location":"development/feature-proposals/joined-table-queries/#alternative-approaches","title":"Alternative Approaches","text":""},{"location":"development/feature-proposals/joined-table-queries/#1-materialized-join-tables","title":"1. Materialized Join Tables","text":"<p>Pre-compute and store common joins as physical tables.</p> <p>Pros: Fast query performance, simple implementation Cons: Storage overhead, data consistency challenges</p>"},{"location":"development/feature-proposals/joined-table-queries/#2-graph-database-approach","title":"2. Graph Database Approach","text":"<p>Model relationships as graph edges instead of foreign keys.</p> <p>Pros: Natural relationship handling, flexible queries Cons: Major architecture change, learning curve</p>"},{"location":"development/feature-proposals/joined-table-queries/#3-view-based-joins","title":"3. View-Based Joins","text":"<p>Create database views for common join patterns.</p> <p>Pros: Leverage database optimization, familiar SQL Cons: Limited to predefined patterns, view management overhead</p>"},{"location":"development/feature-proposals/joined-table-queries/#success-metrics","title":"Success Metrics","text":"<ul> <li>Performance: 90% of join queries complete within target benchmarks</li> <li>Usability: Users can express 80% of common join patterns with simple API</li> <li>Correctness: 99.9% accuracy compared to equivalent SQL joins</li> <li>Adoption: Feature used in &gt;50% of SynthDB projects with multiple tables</li> </ul>"},{"location":"development/feature-proposals/joined-table-queries/#future-enhancements","title":"Future Enhancements","text":"<ul> <li>Join Hints: User-provided optimization hints</li> <li>Parallel Joins: Multi-threaded join processing</li> <li>Streaming Joins: Process large datasets without loading entirely into memory</li> <li>Smart Indexing: Automatic index creation for frequent join patterns</li> <li>Query Planning: Cost-based optimization for complex joins</li> </ul>"},{"location":"development/feature-proposals/joined-table-queries/#related-work","title":"Related Work","text":"<ul> <li>SQL Join Algorithms: Hash joins, nested loop joins, sort-merge joins</li> <li>NoSQL Join Patterns: MongoDB aggregation pipeline, Elasticsearch parent-child</li> <li>EAV Query Optimization: Academic research on efficient EAV querying</li> <li>Graph Databases: Neo4j relationship traversal patterns</li> </ul>"},{"location":"development/feature-proposals/joined-table-queries/#conclusion","title":"Conclusion","text":"<p>Adding joined table queries to SynthDB would significantly enhance its analytical capabilities while maintaining its flexible schema benefits. The implementation requires careful handling of the EAV model but offers substantial value for complex data analysis use cases.</p> <p>The proposed API balances simplicity for basic use cases with power for advanced scenarios. Starting with basic inner joins and expanding to advanced features allows for iterative development and user feedback integration.</p>"},{"location":"development/feature-proposals/safe-user-queries/","title":"Feature Proposal: Safe User Query Execution","text":"Proposed <p>Authors: SynthDB Development Team Created: 2024-06-26 Status: Proposal Complexity: Medium  </p>"},{"location":"development/feature-proposals/safe-user-queries/#summary","title":"Summary","text":"<p>Add the ability for users to execute custom SQL queries on SynthDB databases with built-in safety mechanisms that prevent modification of database structure or access to internal tables. This would enable advanced users to leverage SQL for complex queries while maintaining data integrity and security.</p>"},{"location":"development/feature-proposals/safe-user-queries/#motivation","title":"Motivation","text":""},{"location":"development/feature-proposals/safe-user-queries/#use-cases","title":"Use Cases","text":"<ol> <li>Advanced Analytics: Complex analytical queries that are difficult to express through the standard API</li> <li>Reporting: Custom report generation with sophisticated aggregations and calculations</li> <li>Data Exploration: Ad-hoc queries for data discovery and analysis</li> <li>Migration Support: Easier transition for SQL-experienced users</li> <li>Performance Optimization: Direct SQL for performance-critical queries</li> <li>Integration: Support for SQL-based tools and libraries</li> </ol>"},{"location":"development/feature-proposals/safe-user-queries/#current-limitations","title":"Current Limitations","text":"<ul> <li>All queries must use the predefined API methods</li> <li>No way to execute custom analytical SQL</li> <li>Complex aggregations require multiple API calls and client-side processing</li> <li>Advanced SQL features (window functions, CTEs) are not accessible</li> <li>Difficult to integrate with SQL-based reporting tools</li> </ul>"},{"location":"development/feature-proposals/safe-user-queries/#example-scenarios","title":"Example Scenarios","text":"<pre><code># Current approach - complex client-side aggregation\nusers = db.query('users')\norders = db.query('orders')\n\n# Manual aggregation in Python\nuser_stats = {}\nfor user in users:\n    user_orders = [o for o in orders if o['user_id'] == user['row_id']]\n    user_stats[user['row_id']] = {\n        'name': user['name'],\n        'order_count': len(user_orders),\n        'total_spent': sum(float(o['total']) for o in user_orders),\n        'avg_order': sum(float(o['total']) for o in user_orders) / len(user_orders) if user_orders else 0\n    }\n\n# Desired approach - direct SQL execution\nresult = db.execute_query(\"\"\"\n    SELECT \n        u.name,\n        COUNT(o.row_id) as order_count,\n        SUM(o.total) as total_spent,\n        AVG(o.total) as avg_order_value\n    FROM users u\n    LEFT JOIN orders o ON u.row_id = o.user_id\n    GROUP BY u.row_id, u.name\n    HAVING order_count &gt; 0\n    ORDER BY total_spent DESC\n\"\"\")\n</code></pre>"},{"location":"development/feature-proposals/safe-user-queries/#detailed-design","title":"Detailed Design","text":""},{"location":"development/feature-proposals/safe-user-queries/#core-concepts","title":"Core Concepts","text":""},{"location":"development/feature-proposals/safe-user-queries/#query-types","title":"Query Types","text":"<ol> <li>Read-Only Queries: SELECT statements only, no modifications</li> <li>View Queries: Queries against automatically generated views</li> <li>Analytical Queries: Complex aggregations, window functions, CTEs</li> <li>Restricted Queries: Access only to user tables, not internal schema</li> </ol>"},{"location":"development/feature-proposals/safe-user-queries/#safety-mechanisms","title":"Safety Mechanisms","text":"<ol> <li>SQL Parsing: Parse and validate SQL before execution</li> <li>Whitelist Operations: Only allow safe SQL operations</li> <li>Table Access Control: Restrict access to internal tables</li> <li>Query Transformation: Automatically transform queries to work with SynthDB's views</li> </ol>"},{"location":"development/feature-proposals/safe-user-queries/#api-design","title":"API Design","text":""},{"location":"development/feature-proposals/safe-user-queries/#basic-query-execution","title":"Basic Query Execution","text":"<pre><code>import synthdb\n\ndb = synthdb.connect('app.limbo')  # Uses Limbo by default\n\n# Simple read-only query\nresult = db.execute_query(\"SELECT * FROM users WHERE age &gt; 25\")\n\n# Complex analytical query\nanalytics = db.execute_query(\"\"\"\n    SELECT \n        category,\n        COUNT(*) as product_count,\n        AVG(price) as avg_price,\n        MAX(price) as max_price,\n        MIN(price) as min_price\n    FROM products \n    GROUP BY category\n    ORDER BY avg_price DESC\n\"\"\")\n\n# Query with parameters (safe from SQL injection)\nfiltered_results = db.execute_query(\n    \"SELECT * FROM orders WHERE status = ? AND total &gt; ?\",\n    params=['completed', 100.0]\n)\n</code></pre>"},{"location":"development/feature-proposals/safe-user-queries/#query-validation-and-safety","title":"Query Validation and Safety","text":"<pre><code># Query validation before execution\nvalidation = db.validate_query(\"SELECT * FROM users\")\nif validation.is_safe:\n    result = db.execute_query(validation.query)\nelse:\n    print(f\"Unsafe query: {validation.errors}\")\n\n# Safe query execution with automatic fixes\nresult = db.execute_safe_query(\"\"\"\n    -- This might reference internal tables\n    SELECT * FROM text_values WHERE table_id = 1\n\"\"\")\n# Automatically transforms to:\n# SELECT * FROM users  -- if table_id 1 corresponds to 'users'\n\n# Dry run mode\nplan = db.explain_query(\"SELECT COUNT(*) FROM orders\")\nprint(f\"Estimated rows: {plan.estimated_rows}\")\nprint(f\"Execution time: {plan.estimated_time}ms\")\n</code></pre>"},{"location":"development/feature-proposals/safe-user-queries/#advanced-features","title":"Advanced Features","text":"<pre><code># Query builder with safety\nquery = (db.query_builder()\n    .select('name', 'email', 'COUNT(orders.row_id) as order_count')\n    .from_table('users')\n    .left_join('orders', 'users.row_id = orders.user_id')\n    .where('users.active = ?', [True])\n    .group_by('users.row_id')\n    .having('order_count &gt; ?', [5])\n    .order_by('order_count DESC')\n    .limit(10))\n\nresult = query.execute()\n\n# Query with custom functions\nresult = db.execute_query(\"\"\"\n    SELECT \n        name,\n        email,\n        DATE(created_at) as signup_date,\n        JULIANDAY('now') - JULIANDAY(created_at) as days_since_signup\n    FROM users\n    WHERE signup_date &gt; DATE('2024-01-01')\n\"\"\")\n\n# Window functions\nresult = db.execute_query(\"\"\"\n    SELECT \n        name,\n        total,\n        ROW_NUMBER() OVER (ORDER BY total DESC) as rank,\n        PERCENT_RANK() OVER (ORDER BY total) as percentile\n    FROM orders\n\"\"\")\n</code></pre>"},{"location":"development/feature-proposals/safe-user-queries/#implementation-architecture","title":"Implementation Architecture","text":""},{"location":"development/feature-proposals/safe-user-queries/#sql-parser-and-validator","title":"SQL Parser and Validator","text":"<pre><code>import sqlparse\nfrom sqlparse.sql import Statement, TokenList\nfrom sqlparse.tokens import Keyword, Name\n\nclass SQLValidator:\n    ALLOWED_KEYWORDS = {\n        'SELECT', 'FROM', 'WHERE', 'GROUP BY', 'HAVING', \n        'ORDER BY', 'LIMIT', 'OFFSET', 'JOIN', 'LEFT JOIN',\n        'RIGHT JOIN', 'INNER JOIN', 'OUTER JOIN', 'ON',\n        'AS', 'AND', 'OR', 'NOT', 'IN', 'EXISTS', 'CASE',\n        'WHEN', 'THEN', 'ELSE', 'END', 'WITH'\n    }\n\n    FORBIDDEN_KEYWORDS = {\n        'INSERT', 'UPDATE', 'DELETE', 'DROP', 'CREATE',\n        'ALTER', 'TRUNCATE', 'GRANT', 'REVOKE', 'COMMIT',\n        'ROLLBACK', 'SAVEPOINT', 'PRAGMA'\n    }\n\n    INTERNAL_TABLES = {\n        'table_definitions', 'column_definitions',\n        'text_values', 'integer_values', 'real_values',\n        'boolean_values', 'json_values', 'timestamp_values',\n        'text_value_history', 'integer_value_history',\n        'real_value_history', 'boolean_value_history',\n        'json_value_history', 'timestamp_value_history',\n        'row_id_sequence'\n    }\n\n    def validate_query(self, sql: str) -&gt; ValidationResult:\n        try:\n            parsed = sqlparse.parse(sql)[0]\n            return self._validate_statement(parsed)\n        except Exception as e:\n            return ValidationResult(False, [f\"Parse error: {e}\"])\n\n    def _validate_statement(self, statement: Statement) -&gt; ValidationResult:\n        errors = []\n\n        # Check for forbidden keywords\n        for token in statement.flatten():\n            if token.ttype is Keyword and token.value.upper() in self.FORBIDDEN_KEYWORDS:\n                errors.append(f\"Forbidden operation: {token.value}\")\n\n        # Check for internal table access\n        table_names = self._extract_table_names(statement)\n        for table in table_names:\n            if table.lower() in self.INTERNAL_TABLES:\n                errors.append(f\"Access to internal table not allowed: {table}\")\n\n        # Validate SELECT-only queries\n        if not self._is_select_query(statement):\n            errors.append(\"Only SELECT queries are allowed\")\n\n        return ValidationResult(len(errors) == 0, errors)\n</code></pre>"},{"location":"development/feature-proposals/safe-user-queries/#query-transformation","title":"Query Transformation","text":"<pre><code>class QueryTransformer:\n    def __init__(self, connection):\n        self.connection = connection\n        self.user_tables = self._get_user_tables()\n\n    def transform_query(self, sql: str) -&gt; str:\n        \"\"\"Transform user SQL to work with SynthDB views.\"\"\"\n        parsed = sqlparse.parse(sql)[0]\n\n        # Replace table references with view references\n        transformed = self._replace_table_references(parsed)\n\n        # Add row_id, created_at, updated_at columns if needed\n        transformed = self._ensure_metadata_columns(transformed)\n\n        return str(transformed)\n\n    def _replace_table_references(self, statement):\n        \"\"\"Replace direct table references with SynthDB views.\"\"\"\n        # Implementation would traverse the AST and replace\n        # table names with their corresponding view names\n        pass\n\n    def _get_user_tables(self):\n        \"\"\"Get list of user-created tables (excluding internal tables).\"\"\"\n        return [t['name'] for t in self.connection.list_tables()]\n</code></pre>"},{"location":"development/feature-proposals/safe-user-queries/#execution-engine","title":"Execution Engine","text":"<pre><code>class SafeQueryExecutor:\n    def __init__(self, connection):\n        self.connection = connection\n        self.validator = SQLValidator()\n        self.transformer = QueryTransformer(connection)\n\n    def execute_query(self, sql: str, params: list = None) -&gt; QueryResult:\n        # Validate query safety\n        validation = self.validator.validate_query(sql)\n        if not validation.is_safe:\n            raise UnsafeQueryError(validation.errors)\n\n        # Transform query to work with SynthDB schema\n        transformed_sql = self.transformer.transform_query(sql)\n\n        # Execute with parameters\n        try:\n            cursor = self.connection.execute(transformed_sql, params or [])\n            rows = cursor.fetchall()\n\n            return QueryResult(\n                rows=rows,\n                columns=[desc[0] for desc in cursor.description],\n                row_count=len(rows),\n                execution_time_ms=self._get_execution_time(cursor)\n            )\n        except Exception as e:\n            raise QueryExecutionError(f\"Query failed: {e}\")\n\n    def explain_query(self, sql: str) -&gt; QueryPlan:\n        \"\"\"Get execution plan without running the query.\"\"\"\n        validation = self.validator.validate_query(sql)\n        if not validation.is_safe:\n            raise UnsafeQueryError(validation.errors)\n\n        transformed_sql = self.transformer.transform_query(sql)\n        explain_sql = f\"EXPLAIN QUERY PLAN {transformed_sql}\"\n\n        cursor = self.connection.execute(explain_sql)\n        plan_rows = cursor.fetchall()\n\n        return QueryPlan(plan_rows)\n</code></pre>"},{"location":"development/feature-proposals/safe-user-queries/#security-considerations","title":"Security Considerations","text":""},{"location":"development/feature-proposals/safe-user-queries/#sql-injection-prevention","title":"SQL Injection Prevention","text":"<pre><code># Always use parameterized queries\ndef execute_safe_query(self, sql: str, params: dict = None):\n    # Named parameter binding\n    if params:\n        # Validate parameter names to prevent injection\n        safe_params = self._validate_parameters(params)\n        return self.connection.execute(sql, safe_params)\n    else:\n        return self.connection.execute(sql)\n\ndef _validate_parameters(self, params: dict) -&gt; dict:\n    \"\"\"Validate parameter names and values.\"\"\"\n    safe_params = {}\n    for key, value in params.items():\n        # Only allow alphanumeric parameter names\n        if not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', key):\n            raise ValueError(f\"Invalid parameter name: {key}\")\n        safe_params[key] = value\n    return safe_params\n</code></pre>"},{"location":"development/feature-proposals/safe-user-queries/#access-control","title":"Access Control","text":"<pre><code>class TableAccessControl:\n    def __init__(self, connection):\n        self.connection = connection\n        self.user_tables = set(self._get_user_tables())\n        self.internal_tables = set(SQLValidator.INTERNAL_TABLES)\n\n    def can_access_table(self, table_name: str) -&gt; bool:\n        \"\"\"Check if user can access the specified table.\"\"\"\n        return table_name.lower() in self.user_tables\n\n    def filter_accessible_tables(self, table_names: list) -&gt; list:\n        \"\"\"Filter list to only include accessible tables.\"\"\"\n        return [t for t in table_names if self.can_access_table(t)]\n</code></pre>"},{"location":"development/feature-proposals/safe-user-queries/#cli-integration","title":"CLI Integration","text":"<pre><code># Execute custom queries\nsdb query-sql \"SELECT COUNT(*) FROM users WHERE active = true\"\n\n# Query with parameters\nsdb query-sql \"SELECT * FROM orders WHERE total &gt; ?\" --params 100.0\n\n# Output formats\nsdb query-sql \"SELECT name, email FROM users\" --format csv\nsdb query-sql \"SELECT * FROM products\" --format json --output products.json\n\n# Validate query without execution\nsdb query-sql \"SELECT * FROM users\" --validate-only\n\n# Explain query execution plan\nsdb query-sql \"SELECT * FROM orders GROUP BY status\" --explain\n\n# Interactive SQL shell\nsdb sql-shell\n# SynthDB SQL&gt; SELECT COUNT(*) FROM users;\n# SynthDB SQL&gt; .tables\n# SynthDB SQL&gt; .schema users\n# SynthDB SQL&gt; .exit\n</code></pre>"},{"location":"development/feature-proposals/safe-user-queries/#implementation-plan","title":"Implementation Plan","text":""},{"location":"development/feature-proposals/safe-user-queries/#phase-1-basic-sql-execution-3-4-weeks","title":"Phase 1: Basic SQL Execution (3-4 weeks)","text":"<ul> <li> SQL parser and validator implementation</li> <li> Basic SELECT query support</li> <li> Table access control</li> <li> Parameter binding for safety</li> <li> Connection API integration</li> </ul>"},{"location":"development/feature-proposals/safe-user-queries/#phase-2-query-transformation-2-3-weeks","title":"Phase 2: Query Transformation (2-3 weeks)","text":"<ul> <li> Query transformer for SynthDB views</li> <li> Automatic table reference replacement</li> <li> Error handling and validation</li> <li> Basic testing and validation</li> </ul>"},{"location":"development/feature-proposals/safe-user-queries/#phase-3-advanced-features-3-4-weeks","title":"Phase 3: Advanced Features (3-4 weeks)","text":"<ul> <li> Complex SQL features (JOINs, subqueries, CTEs)</li> <li> Query explanation and planning</li> <li> Performance optimization</li> <li> CLI integration and SQL shell</li> </ul>"},{"location":"development/feature-proposals/safe-user-queries/#phase-4-production-features-2-3-weeks","title":"Phase 4: Production Features (2-3 weeks)","text":"<ul> <li> Comprehensive security testing</li> <li> Performance benchmarking</li> <li> Documentation and examples</li> <li> Integration with reporting tools</li> </ul>"},{"location":"development/feature-proposals/safe-user-queries/#api-examples","title":"API Examples","text":""},{"location":"development/feature-proposals/safe-user-queries/#basic-usage","title":"Basic Usage","text":"<pre><code>import synthdb\n\n# Setup\ndb = synthdb.connect('analytics.limbo')  # Uses Limbo by default\n\n# Simple queries\nuser_count = db.execute_query(\"SELECT COUNT(*) as total FROM users\")[0]['total']\n\n# Analytical queries\ntop_customers = db.execute_query(\"\"\"\n    SELECT \n        u.name,\n        u.email,\n        COUNT(o.row_id) as order_count,\n        SUM(o.total) as lifetime_value,\n        AVG(o.total) as avg_order_value\n    FROM users u\n    JOIN orders o ON u.row_id = o.user_id\n    WHERE o.status = 'completed'\n    GROUP BY u.row_id\n    ORDER BY lifetime_value DESC\n    LIMIT 10\n\"\"\")\n\nfor customer in top_customers:\n    print(f\"{customer['name']}: ${customer['lifetime_value']:.2f}\")\n</code></pre>"},{"location":"development/feature-proposals/safe-user-queries/#advanced-analytics","title":"Advanced Analytics","text":"<pre><code># Time series analysis\nmonthly_sales = db.execute_query(\"\"\"\n    SELECT \n        strftime('%Y-%m', created_at) as month,\n        COUNT(*) as order_count,\n        SUM(total) as revenue,\n        AVG(total) as avg_order_value\n    FROM orders\n    WHERE status = 'completed'\n    GROUP BY month\n    ORDER BY month\n\"\"\")\n\n# Cohort analysis\ncohort_data = db.execute_query(\"\"\"\n    WITH first_purchase AS (\n        SELECT \n            user_id,\n            MIN(DATE(created_at)) as first_purchase_date\n        FROM orders\n        GROUP BY user_id\n    ),\n    monthly_activity AS (\n        SELECT \n            o.user_id,\n            fp.first_purchase_date,\n            strftime('%Y-%m', o.created_at) as activity_month,\n            COUNT(*) as orders_in_month\n        FROM orders o\n        JOIN first_purchase fp ON o.user_id = fp.user_id\n        WHERE o.status = 'completed'\n        GROUP BY o.user_id, activity_month\n    )\n    SELECT \n        first_purchase_date,\n        COUNT(DISTINCT user_id) as cohort_size,\n        activity_month,\n        COUNT(DISTINCT user_id) as active_users\n    FROM monthly_activity\n    GROUP BY first_purchase_date, activity_month\n    ORDER BY first_purchase_date, activity_month\n\"\"\")\n\n# Product performance\nproduct_stats = db.execute_query(\"\"\"\n    SELECT \n        p.name,\n        p.category,\n        COUNT(oi.row_id) as times_ordered,\n        SUM(oi.quantity) as total_quantity,\n        AVG(oi.price) as avg_price,\n        SUM(oi.quantity * oi.price) as total_revenue\n    FROM products p\n    JOIN order_items oi ON p.row_id = oi.product_id\n    JOIN orders o ON oi.order_id = o.row_id\n    WHERE o.status = 'completed'\n    GROUP BY p.row_id\n    HAVING times_ordered &gt;= 5\n    ORDER BY total_revenue DESC\n\"\"\")\n</code></pre>"},{"location":"development/feature-proposals/safe-user-queries/#performance-considerations","title":"Performance Considerations","text":""},{"location":"development/feature-proposals/safe-user-queries/#query-optimization","title":"Query Optimization","text":"<ul> <li>View Caching: Cache generated views for better performance</li> <li>Index Recommendations: Suggest indexes for frequently queried columns</li> <li>Query Planning: Analyze and optimize complex queries</li> <li>Result Caching: Cache results of expensive analytical queries</li> </ul>"},{"location":"development/feature-proposals/safe-user-queries/#resource-management","title":"Resource Management","text":"<ul> <li>Query Timeouts: Prevent long-running queries from blocking</li> <li>Memory Limits: Control memory usage for large result sets</li> <li>Concurrent Access: Handle multiple concurrent query executions</li> </ul>"},{"location":"development/feature-proposals/safe-user-queries/#security-model","title":"Security Model","text":""},{"location":"development/feature-proposals/safe-user-queries/#threat-prevention","title":"Threat Prevention","text":"<ol> <li>SQL Injection: Parameterized queries and input validation</li> <li>Data Exfiltration: Read-only access, no sensitive table exposure</li> <li>Resource Exhaustion: Query timeouts and memory limits</li> <li>Privilege Escalation: Strict table access control</li> </ol>"},{"location":"development/feature-proposals/safe-user-queries/#audit-trail","title":"Audit Trail","text":"<pre><code># Query execution logging\nclass QueryAuditor:\n    def log_query_execution(self, sql: str, params: list, user: str, result_count: int):\n        audit_entry = {\n            'timestamp': datetime.utcnow(),\n            'user': user,\n            'query': sql,\n            'parameters': params,\n            'result_count': result_count,\n            'execution_time_ms': execution_time\n        }\n        self.audit_log.append(audit_entry)\n</code></pre>"},{"location":"development/feature-proposals/safe-user-queries/#alternative-approaches","title":"Alternative Approaches","text":""},{"location":"development/feature-proposals/safe-user-queries/#1-query-templates","title":"1. Query Templates","text":"<p>Provide predefined query templates for common analytical patterns.</p> <p>Pros: Safe, optimized, easy to use Cons: Limited flexibility, requires template maintenance</p>"},{"location":"development/feature-proposals/safe-user-queries/#2-restricted-sql-dialect","title":"2. Restricted SQL Dialect","text":"<p>Create a custom SQL-like language with only safe operations.</p> <p>Pros: Complete control over safety, optimized for SynthDB Cons: Learning curve, limited SQL compatibility</p>"},{"location":"development/feature-proposals/safe-user-queries/#3-view-based-access","title":"3. View-Based Access","text":"<p>Only allow queries against predefined analytical views.</p> <p>Pros: Simple implementation, good performance Cons: Limited to predefined analyses, view management overhead</p>"},{"location":"development/feature-proposals/safe-user-queries/#success-metrics","title":"Success Metrics","text":"<ul> <li>Safety: Zero successful SQL injection or data breach attempts</li> <li>Performance: 95% of analytical queries complete within 5 seconds</li> <li>Usability: Users can express 90% of analytical needs through SQL</li> <li>Adoption: Feature used in &gt;60% of SynthDB projects requiring analytics</li> </ul>"},{"location":"development/feature-proposals/safe-user-queries/#future-enhancements","title":"Future Enhancements","text":"<ul> <li>Query Optimization Engine: Advanced query planning and optimization</li> <li>Cached Analytics: Automatic caching of expensive analytical queries</li> <li>Real-time Analytics: Streaming query support for real-time data</li> <li>SQL Extensions: Custom functions specific to SynthDB's domain</li> <li>Integration APIs: Direct integration with BI tools and data visualization</li> </ul>"},{"location":"development/feature-proposals/safe-user-queries/#related-work","title":"Related Work","text":"<ul> <li>SQL Parsing: sqlparse, SQLAlchemy expression language</li> <li>Query Security: PostgreSQL RLS, MySQL query rewriting</li> <li>Analytics Databases: ClickHouse analytical query patterns</li> <li>Sandbox Execution: Safe code execution patterns</li> </ul>"},{"location":"development/feature-proposals/safe-user-queries/#conclusion","title":"Conclusion","text":"<p>Adding safe user query execution to SynthDB would significantly enhance its analytical capabilities while maintaining security and data integrity. The proposed implementation balances flexibility with safety, enabling advanced SQL analytics while preventing harmful operations.</p> <p>The security-first design ensures that users can leverage the full power of SQL for analytics without compromising the database or accessing sensitive internal structures. This feature would make SynthDB much more attractive for analytical workloads and data exploration use cases.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide will help you install SynthDB and get it running on your system.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.8 or higher</li> <li>pip or uv package manager</li> </ul>"},{"location":"getting-started/installation/#quick-installation","title":"Quick Installation","text":""},{"location":"getting-started/installation/#recommended-install-with-uv","title":"\ud83d\ude80 Recommended: Install with uv","text":"<p>uv is the fastest Python package manager and installer:</p> <pre><code># Install uv (if you don't have it)\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Install SynthDB\nuv add synthdb\n</code></pre>"},{"location":"getting-started/installation/#traditional-installation-with-pip","title":"Traditional Installation with pip","text":"<pre><code>pip install synthdb\n</code></pre>"},{"location":"getting-started/installation/#backend-options","title":"Backend Options","text":"<p>SynthDB supports two database backends:</p>"},{"location":"getting-started/installation/#limbo-default","title":"Limbo (Default)","text":"<ul> <li>Pros: Fastest performance, modern Rust implementation, SQLite-compatible</li> <li>Cons: Alpha software, may have compatibility issues</li> <li>Best for: Development, single-user applications, performance testing</li> </ul>"},{"location":"getting-started/installation/#sqlite-stable","title":"SQLite (Stable)","text":"<ul> <li>Pros: Battle-tested, maximum compatibility, stable, embedded</li> <li>Cons: Limited concurrent writes</li> <li>Best for: Production apps, desktop apps, small web apps, embedded systems</li> </ul> <p>The Limbo backend is automatically installed with SynthDB. If it's not available on your system, SynthDB will automatically fall back to SQLite.</p>"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":""},{"location":"getting-started/installation/#configuration-file-support","title":"Configuration File Support","text":"<p>For YAML and TOML configuration file support:</p> <pre><code># With uv\nuv add \"synthdb[config]\"\n\n# With pip\npip install \"synthdb[config]\"\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>If you want to contribute to SynthDB or run the latest development version:</p> <pre><code># Clone the repository\ngit clone https://github.com/russellromney/synthdb\ncd synthdb\n\n# With uv (recommended - 10-100x faster!)\nuv sync                 # Install dependencies\nmake dev               # Setup development environment\nmake test              # Run tests\nmake lint              # Run linting\n\n# With pip (traditional)\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>After installation, verify that SynthDB is working:</p> <pre><code># Check version\npython -c \"import synthdb; print(synthdb.__version__)\"\n\n# Test basic functionality\npython -c \"\nimport synthdb\ndb = synthdb.connect('test.limbo')  # Uses Limbo by default\ndb.create_table('test')\nprint('\u2705 SynthDB is working!')\n\"\n\n# Test CLI\nsynthdb --help\n# or use the shorter alias:\nsdb --help\n</code></pre>"},{"location":"getting-started/installation/#environment-variables","title":"Environment Variables","text":"<p>You can configure SynthDB behavior with environment variables:</p> <pre><code># Set default backend (optional - Limbo is already default)\nexport SYNTHDB_BACKEND=limbo\n\n# Set default database path\nexport SYNTHDB_DEFAULT_PATH=myapp.limbo\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/installation/#limbo-backend-not-available","title":"Limbo backend not available","text":"<pre><code>Warning: Limbo backend not available, falling back to SQLite\n</code></pre> <p>This is normal and not an error. SynthDB will use SQLite as the backend, which works perfectly for all operations.</p>"},{"location":"getting-started/installation/#permission-errors","title":"Permission errors","text":"<pre><code>Permission denied: Cannot write to database file\n</code></pre> <p>Make sure you have write permissions to the directory where you're creating the database file.</p>"},{"location":"getting-started/installation/#import-errors","title":"Import errors","text":"<pre><code>ModuleNotFoundError: No module named 'synthdb'\n</code></pre> <p>Make sure you've activated the correct Python environment where SynthDB is installed.</p>"},{"location":"getting-started/installation/#getting-help","title":"Getting Help","text":"<p>If you encounter issues:</p> <ol> <li>Check the Troubleshooting Guide</li> <li>Search existing issues</li> <li>Create a new issue</li> </ol>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that SynthDB is installed, continue with:</p> <ul> <li>Quick Start Guide - Get up and running in minutes</li> <li>Basic Concepts - Understand how SynthDB works</li> <li>Connection API - Learn the Python API</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start Guide","text":"<p>Get up and running with SynthDB in just a few minutes! This guide will walk you through the essential operations.</p>"},{"location":"getting-started/quickstart/#your-first-database","title":"Your First Database","text":"<p>Let's create a simple user management system:</p> <pre><code>import synthdb\n\n# Create a connection (database file will be created automatically)\ndb = synthdb.connect('my_app.limbo')  # Uses Limbo by default\n\n# Create a table\ndb.create_table('users')\n\n# Add columns with automatic type inference\ndb.add_columns('users', {\n    'name': 'Alice',           # Infers 'text' type\n    'email': 'alice@test.com', # Infers 'text' type\n    'age': 25,                 # Infers 'integer' type\n    'active': True,            # Infers 'boolean' type\n    'metadata': {'role': 'admin'}  # Infers 'json' type\n})\n\nprint(\"\u2705 Table created with columns!\")\n</code></pre>"},{"location":"getting-started/quickstart/#insert-data","title":"Insert Data","text":"<p>SynthDB automatically assigns unique row IDs:</p> <pre><code># Insert with auto-generated ID\nuser_id = db.insert('users', {\n    'name': 'Bob Smith',\n    'email': 'bob@example.com',\n    'age': 30,\n    'active': True,\n    'metadata': {'role': 'user', 'department': 'engineering'}\n})\n\nprint(f\"\u2705 Inserted user with ID: {user_id}\")\n\n# Insert with explicit ID (useful for migrations)\ndb.insert('users', {\n    'name': 'Carol Brown',\n    'email': 'carol@example.com',\n    'age': 28,\n    'active': False\n}, row_id=1000)\n\nprint(\"\u2705 Inserted user with explicit ID: 1000\")\n</code></pre>"},{"location":"getting-started/quickstart/#query-data","title":"Query Data","text":"<p>Query your data with familiar SQL-like syntax:</p> <pre><code># Get all users\nall_users = db.query('users')\nprint(f\"Total users: {len(all_users)}\")\n\n# Filter with WHERE clause\nactive_users = db.query('users', 'active = \"true\"')\nprint(f\"Active users: {len(active_users)}\")\n\n# Filter by age\nyoung_users = db.query('users', 'age &lt; 30')\nprint(f\"Users under 30: {len(young_users)}\")\n\n# Display results\nfor user in active_users:\n    print(f\"  {user['name']} ({user['age']}) - {user['email']}\")\n</code></pre>"},{"location":"getting-started/quickstart/#update-data","title":"Update Data","text":"<p>Use upsert to insert or update based on key columns:</p> <pre><code># Update existing user or insert if not found\nupdated_id = db.upsert('users', {\n    'name': 'Bob Smith',\n    'email': 'bob.smith@newcompany.com',  # Updated email\n    'age': 31,                           # Updated age\n    'active': True,\n    'metadata': {'role': 'senior_engineer'}  # Updated role\n}, key_columns=['name'])  # Match on name\n\nprint(f\"\u2705 Upserted user with ID: {updated_id}\")\n</code></pre>"},{"location":"getting-started/quickstart/#evolve-your-schema","title":"Evolve Your Schema","text":"<p>Add new columns without migrations:</p> <pre><code># Add new columns to existing table\ndb.add_columns('users', {\n    'created_at': '2024-01-01',  # Infers 'timestamp' type\n    'salary': 75000.0,          # Infers 'real' type\n    'skills': ['python', 'sql'] # Infers 'json' type\n})\n\n# Insert data with new columns\ndb.insert('users', {\n    'name': 'David Wilson',\n    'email': 'david@example.com',\n    'age': 35,\n    'active': True,\n    'created_at': '2024-06-26',\n    'salary': 95000.0,\n    'skills': ['python', 'rust', 'database']\n})\n\nprint(\"\u2705 Schema evolved! New columns added.\")\n</code></pre>"},{"location":"getting-started/quickstart/#inspect-your-database","title":"Inspect Your Database","text":"<p>Explore your database structure:</p> <pre><code># List all tables\ntables = db.list_tables()\nfor table in tables:\n    print(f\"Table: {table['name']} (ID: {table['id']})\")\n\n# List columns in a table\ncolumns = db.list_columns('users')\nfor col in columns:\n    print(f\"  Column: {col['name']} ({col['data_type']})\")\n\n# Get final count\nfinal_users = db.query('users')\nprint(f\"\\n\ud83d\udcca Final user count: {len(final_users)}\")\n</code></pre>"},{"location":"getting-started/quickstart/#cli-quick-start","title":"CLI Quick Start","text":"<p>SynthDB also provides a powerful CLI for database operations:</p> <pre><code># Initialize a database\nsdb database init my_cli_app.limbo  # Uses Limbo by default\n\n# Create a table\nsdb table create products\n\n# Add columns\nsdb table add column products name text\nsdb table add column products price real\nsdb table add column products in_stock boolean\n\n# Insert data using JSON\nsdb add products '{\"name\": \"Widget\", \"price\": 19.99, \"in_stock\": true}'\nsdb add products '{\"name\": \"Gadget\", \"price\": 29.99, \"in_stock\": false}'\n\n# Query data\nsdb query products\nsdb query products --where \"price &gt; 20\"\n\n# List tables and columns\nsdb table list\nsdb table list products\n</code></pre>"},{"location":"getting-started/quickstart/#backend-selection","title":"Backend Selection","text":"<p>Choose the right backend for your needs:</p> <pre><code># Use Limbo for best performance (default)\ndb = synthdb.connect('fast_app.limbo')  # Uses Limbo automatically\n\n# Use SQLite for maximum stability  \ndb = synthdb.connect('stable_app.db', backend='sqlite')\n\n# Auto-detection by file extension\ndb = synthdb.connect('app.limbo')  # Uses Limbo (recommended)\ndb = synthdb.connect('app.db')     # Uses SQLite\n</code></pre>"},{"location":"getting-started/quickstart/#error-handling","title":"Error Handling","text":"<p>SynthDB provides helpful error messages:</p> <pre><code>try:\n    # Try to insert duplicate ID\n    db.insert('users', {'name': 'Test'}, row_id=1000)\nexcept ValueError as e:\n    print(f\"Expected error: {e}\")\n\ntry:\n    # Try to access non-existent column\n    db.query('users', 'nonexistent_column = \"value\"')\nexcept Exception as e:\n    print(f\"Expected error: {e}\")\n</code></pre>"},{"location":"getting-started/quickstart/#complete-example","title":"Complete Example","text":"<p>Here's everything together in a complete script:</p> <pre><code>import synthdb\n\ndef main():\n    # Connect to database\n    db = synthdb.connect('quickstart.limbo')  # Uses Limbo by default\n\n    # Create and populate table\n    db.create_table('products')\n    db.add_columns('products', {\n        'name': 'text',\n        'description': 'A sample product',\n        'price': 19.99,\n        'in_stock': True,\n        'tags': ['electronics', 'gadgets']\n    })\n\n    # Insert some products\n    products = [\n        {'name': 'Smartphone', 'price': 599.99, 'in_stock': True, 'tags': ['electronics', 'mobile']},\n        {'name': 'Laptop', 'price': 1299.99, 'in_stock': True, 'tags': ['electronics', 'computer']},\n        {'name': 'Headphones', 'price': 199.99, 'in_stock': False, 'tags': ['electronics', 'audio']},\n    ]\n\n    for product in products:\n        product_id = db.insert('products', product)\n        print(f\"Added {product['name']} with ID {product_id}\")\n\n    # Query and display results\n    expensive_products = db.query('products', 'price &gt; 500')\n    print(f\"\\nExpensive products ({len(expensive_products)}):\")\n    for product in expensive_products:\n        status = \"\u2705 In Stock\" if product['in_stock'] == 'true' else \"\u274c Out of Stock\"\n        print(f\"  {product['name']}: ${product['price']} - {status}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you've seen the basics, explore more advanced features:</p> <ul> <li>Connection API Guide - Deep dive into the Python API</li> <li>CLI Usage - Master the command-line interface</li> <li>Working with Tables - Advanced table operations</li> <li>Data Operations - Complex queries and data manipulation</li> <li>Examples - Real-world usage patterns</li> </ul>"},{"location":"getting-started/quickstart/#clean-up","title":"Clean Up","text":"<p>If you want to remove the test databases created in this guide:</p> <pre><code>rm quickstart.limbo my_app.limbo my_cli_app.limbo\n</code></pre>"}]}